<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HTTP状态码之3XX]]></title>
      <url>%2F2017%2F10%2F21%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%B9%8B3XX%2F</url>
      <content type="text"><![CDATA[关键字HTTP 重定向 前言3XX 状态码都是重定向相关，但是不同的3XX有着不同的区别，导致使用场景上的区别，当我们设置重定向的时候，这点尤为重要。之前做了个服务器处理表单的代码，体会到了不同状态码的区别。 123456789101112// 添加中间件处理POST请求表单app.use(require('body-parser')());app.get('/newsletter',(req, res) =&gt; &#123; res.render('newsletter',&#123;csrf: 'CSRF token goes here'&#125;);&#125;);app.post('/process',(req, res) =&gt; &#123; console.log('Form (form querystring): ' + req.query.form); console.log('CSRF token (from hidden from field): ' + req.body._csrf); console.log('Name (from visiable from field): ' + req.body.email); res.redirect(303, '/thanks-you'); // 这里用到了重定向&#125;); 301 和 302，303的区别在一般表单提交中，我们往往通过重定向的方式提供一个新的视图，而如果不通过重定向的方式渲染视图，访问者的地址栏仍旧不会变，这是不好的。在这种情况下使用 303(或 302) 重定向，而不是 301 重定向，这一点非常 重要。 301 重定向是“永久”的，意味着浏览器会缓存重定向目标。如果使 用 301 重定向并且试图第二次提交表单，浏览器会绕过整个 /process 处理程 序直接进入/thank you页面，因为它正确地认为重定向是永久性的。另一方 面， 303 重定向告诉浏览器“是的，你的请求有效，可以在这里找到响应”， 并且不会缓存重定向目标。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配到了新的 URI ，以后应该使用资源所指向的 URI 。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 理解：显然301这种重定向适用于的场景不适合表单跳转，而是需要更换域名或有多个域名指向一个网站。或者多个网站想合并到一个主域名。 为什么一定要用301跳转？如果使用head标签内meta refresh或者JS跳转或302转向,这样很容易被百度或其他搜索引擎视为作弊被惩罚降权。这时要是用301重定向。 百度收录的地址大部分是旧域名下的链接，此时相当于流量和权重都在旧域名，那么主域名就很不划算，要做301转向。 原域名被百度k掉，要做301重定向。什么意思，就是说，旧域名被k，会有很长时间不被收录，那么启用新域名，把原来的域名做301转向即可。 PS：有www和无www域名：www.gw020.com 和gw020.com 其实是2个不同的域名，就是说带有www的域名其实只是个二级域名。因为非常常用，所以习惯必须有www。而对于搜索引擎来说，这是2个域名，所以会出现经常是没有www的域名被收录很多，而有www的域名没有被收录，或者收录量完全想法或不同。如果很在意这个流量转化和权重集中，可以把其中一个做301重定向。方法同上。 302 Found 302状态码主要是提示该次为临时重定向，故而除非特别指定了缓存头部指示，该状态码不可缓存。对于服务器，通常会给浏览器发送HTTP Location头部来重定向到新的新位置。 那么言下之意是什么呢？就意味着资源不是被永久移动，已移动的资源的URI将来还可能发生改变。 302状态码的特征其特征被定义为： 客户端收到的新的 URI，不是原始请求资源的替代引用。只有当服务器发出 Cache-Control 或 Expires 头字段进行指示，此响应才能被缓存，否则不能被缓存。 临时URI应该由响应头部中的 Location 字段给出。除非请求方法是 HEAD ，否则响应的实体应该包含一个带有超链接到新的URI的短 HTML 注释。 如果在除 GET 或 HEAD 两种请求方法之外的请求时，接收到302状态码，客户端不得自动重定向请求，除非用户可以确认；否则可能会更改发出请求的条件。 如果一个客户端有链接编辑能力，其应当把所有的引用链接重定向到新的URL上。 重定向到新地址时，客户端必须使用GET方法请求新地址。 从维基百科中看到并不推荐使用302状态码，这是为什么呢？ 302 重定向和网址劫持（URL hijacking）302 重定向和网址劫持（URL hijacking） 为什么不推荐使用，但还是存在302呢？虽然 RFC 1945 和 RFC 2068 两个规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为 303响应 ，并且径自使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法，这是不规范的实现。 因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303和307的由来 从上面的介绍可以知道，HTTP1.1和HTTP1.0的302状态码意义是一样的，浏览器对它的处理也是一样的。POST方法的重定向在未询问用户的情况下就变成GET，这种不符合文档规范的问题依然存在。实践在前而文档在后，HTTP1.1把这种POST变GET的行为纳入了RFC文档：HTTP1.1新加入303和307状态码。 文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。 HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。 总结303和307是HTTP1.1新加的服务器响应文档的状态码，它们是对HTTP1.0中的302状态码的细化，主要用在对非GET、HEAD方法的响应上。文档规定：浏览器对303状态码的处理跟原来浏览器对HTTP1.0的302状态码的处理方法一样；浏览器对307状态码处理则跟原来HTTP1.0文档里对302的描述一样。 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。 在HTTP1.1中，302理论上是要被放弃掉的，它被细化为303和307，但为了兼容，它目前还在业界中大量使用，而303和307状态码我还没遇到过（没有使用场景，也没抓到过这样的响应报文）。为什么业界少使用303和307呢？对于GET和HEAD方法来说，307是没必要存在的，用302或者303就可以满足需求了，307仅在POST方法的重定向上有用处。所以我猜测它们少见的原因有两方面：1、POST方法重定向的使用场景太少，使得307状态码没有用武之地；2、GET方法虽然常需要使用的重定向，但使用302状态码也能正确运转，再考虑到微乎其微的兼容问题（现在的浏览器怎么可能不支持HTTP1.1呢！），也就没有使用303的必要了。 参考： 《图解HTTP协议》 维基百科 - HTTP - 302 何时应该使用301重定向？ 3.HTTP状态码302、303和307的故事]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux起源]]></title>
      <url>%2F2017%2F10%2F19%2FLinux%E8%B5%B7%E6%BA%90%2F</url>
      <content type="text"><![CDATA[关键词Linux Unix 起源 Linux、Unix的关系提到Linux的起源，不得不提到Unix，因为本质上Linux是一个类Unix系统。MIT[麻省理工学院]有一个可供30个人同时使用的分时操作系统。但是在那个时候，30个人并发太少了，当时的计算机非常贵，只有30个人能用终端登录到计算机使用远远不够，于是在1965年，由贝尔实验室（Bell Labs）和MIT决定要让30个人的分时操作系统提高到300人同时使用，并且把这个称之为MULTICS计划。 这个计划经历了4年时间，到了1969年，由于进度过慢，MULTICS计划失败了。虽然计划失败了，但是Ken Thompson（后被称为UNIX之父）却并没有把MULTICS计划精华部分的代码丢弃，他在这个基础之上开发了一个file server system[文件系统] ，并且在贝尔实验室受到了广泛的欢迎和使用。 到了1973年的时候,Ken Thompson 与Dennis Ritchie成功地用C语言重 Unix Unix 写了Unix的第三版内核。至此，Unix这个操作系统修改、移植相当便利，为Unix日后的普及打下了坚实的基础。 Unix出现以后最大的影响在于开源代码，它把源码内核共享，而几家大公司基于Unix的开源代码的二次开发，于是IBM基于此开发了一个 AIX 的 类Unix 操作系统；Sun公司基于此开发了一个 solaris 的操作系统；HP公司开发了一个 HP-UX 操作系统；而苹果公司基于此开发了 A/UX 的类Unix系统… 所以关于Unix和Linux的关系可以这么理解： Unix是一个很大的范畴，就像我们今天说去吃炒菜，炒菜就是一个类别，大的范围。Linux继承自Unix Unix特性 UNIX系统是一个多用户，多任务的分时操作系统。 UNIX的系统结构可分为三部分：操作系统内核（是UNIX系统核心管理和控制中心，在系统启动或常驻内存），系统调用（供程序开发者开发应用程序时调用系统组件，包括进程管理，文件管理，设备状态等），应用程序（包括各种开发工具，编译器，网络通讯处理程序等，所有应用程序都在Shell的管理和控制下为用户服务）。 UNIX系统大部分是由C语言编写的，这使得系统易读，易修改，易移植。 UNIX提供了丰富的，精心挑选的系统调用，整个系统的实现十分紧凑，简洁。 UNIX提供了功能强大的可编程的Shell语言（外壳语言）作为用户界面具有简洁，高效的特点。 UNIX系统采用树状目录结构，具有良好的安全性，保密性和可维护性。 UNIX系统采用进程对换（Swapping）的内存管理机制和请求调页的存储方式，实现了虚拟内存管理，大大提高了内存的使用效率。 UNIX系统提供多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信。 Linux的特点 免费/开源 支持多进程/多用户 Linux系统同时可以支持多个用户，每个用户对自己的文件设备有特殊的权利，能够保证各用户之间互不干扰，就像手机开了助手一样，同时登陆多个qq账号，当硬件配置非常高时，每个用户还可以同时执行多个任务、多个线程同时工作、提高效率，简直是完美的一塌糊涂，单凭多用户而言就完爆其他操作系统。 安全性好 对内存和文件管理优越 由于Linux要保证其稳定性，所以并没有像其它操作系统一样内核如此臃肿庞大、漏洞百出，随着Linux内核的不断更新，不断提升着优势，Linux操作系统能把服务器的硬件优势体现的淋漓尽致，因为Linux系统吸取了Unix系统近1/4世纪发展的经验，最主要的是Linux开放源代码，保证系统稳定性，更好的调用硬件功能，同时还提供了丰富的系统资源工具top，freee，df，vmstat，dmesg，iostat，sar，uptime等，方便查看资源的利用率。 稳定性/高效性 你也许会听到Windows服务器长时间运行而突然宕机，但你绝不会听到Linux系统服务器因为长时间不关机会卡死，在Linux上几乎是不会出现这种情况的。Linux服务器可以无休止的运行下去不宕机，因为它继承了Unix卓越的稳定性和高效性。正因为它的稳定才获得了众多用户的青睐，因为它的高效，它的使用范围更加广阔，然而Linux还可以提供一些高可靠性的服务，比如:LNMP、虚拟化、数据库服务等等。 Linux是用来干嘛的?Linux最主要的用途肯定是用在做服务器 引用一句话：『你来是因为产品，你留下是因为生态系统』Linux 作为服务器的优势是，他目前具有最好的生态系统，服务器端的各种软件都为它而设计，默认都认为你是在 Linux 上跑，你要是整一个非 Linux 的服务器，你得有足够的心理准备，因为出现任何问题，你可能未必能找到能帮你解决问题的人。 作者：pansz链接：https://www.zhihu.com/question/19738282/answer/15530861来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 参考： 为什么程序员都喜欢Linux操作系统？ Linux 作为服务器操作系统的优势是什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件]]></title>
      <url>%2F2017%2F08%2F09%2FJavaScript-%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[JavaScript事件关键词： 事件流 事件冒泡 事件捕获 事件委托 事件处理函数被执行的时机 自定义事件 事件触发的三个阶段 事件对象 事件目标元素 什么是事件流？什么是IE事件流？IE事件流和DOM事件流的区别是什么？事件流描述的是从页面中接收到事件的顺序，IE的事件流是事件冒泡（event bubbling）,而Netscape提出和支持的是事件捕获流，但由于Netscape已经被淘汰了，所以没有只支持事件捕获的浏览器了，而DOM 2级事件模型是把两种事件合并起来了。 DOM事件流的目的旨在通过事件捕获为截获事件提供了机会，通过事件冒泡设置处理程序响应事件。 #事件触发的三个阶段 1.document 往事件触发地点，捕获前进，遇到相同注册事件立即触发执行 2.到达事件位置，触发事件 3.事件触发地点往 document 方向，冒泡前进，遇到相同注册事件立即触发 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById('parent').onclick = function() &#123; alert('father emit!'); &#125; document.getElementById('child').onclick = function() &#123; alert('child emit!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从上个例子的结果child emit！father emit！可以看出，通过onload注册的事件仅仅支持冒泡，也就是说通过DOM 0级的注册的事件处理程序仅仅只是在冒泡阶段被处理。 假如一个元素既注册了冒泡，也注册了捕获，是捕获先被触发呢还是冒泡先被触发呢？根据DOM2级事件流，捕获——到达——冒泡的顺序，应该是先发生捕获，再发生冒泡。 测试结果： 点击父元素，父元素捕获——父元素冒泡，符合先捕获后冒泡的事件流机制。 点击子元素，父元素捕获——子元素冒泡——子元素捕获——父元素冒泡，这里可以发现一个很重要的点，即当一个元素同时存在捕获和冒泡时，会按照注册的时候响应事件处理程序 如果是通过DOM 0级注册的冒泡，通过DOM2级注册的捕获在同一元素上，以上的结论还成立吗？还是先捕获再冒泡？ 结论还是按照注册的顺序响应事件处理程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 父元素按照先捕获后冒泡的方式注册 document.getElementById('parent').addEventListener('click',function() &#123; alert('parent event capturing emit!'); &#125;,true); document.getElementById('parent').addEventListener('click',function() &#123; alert('parent event bubbling emit!'); &#125;,false); // 子元素按照先冒泡后捕获的方式注册 document.getElementById('child').addEventListener('click',function() &#123; alert('child event bubbling emit!'); &#125;,false); // document.getElementById('child').onclick = function() &#123; // alert('child event bubbling emit!'); // &#125; [3] document.getElementById('child').addEventListener('click',function() &#123; alert('child event capturing emit!'); &#125;,true); &lt;/script&gt;&lt;/body&gt; 对事件流和事件处理程序的理解个人认为事件流在DOM2级以后，就是一种事件发生时，事件在DOM中逐级传播的正常现象，这种现象不由我们控制，而我们能做的只是决定我们需要在什么阶段响应事件。是冒泡阶段or捕获阶段？ 这个由我们来决定。 事件处理程序则是响应事件发生做点什么，事件处理程序被调用依赖于两个条件：事件传播到了注册的元素上且在指定的阶段。 举例，假如一个事件同时存在事件捕获和事件冒泡，事件捕获先注册，事件冒泡后注册，那么如果在事件捕获时通过调用e.stopPropagation()阻止事件的进一步传播，那是不是意味着冒泡阶段的事件处理程序不会再被调用？ 注意，这里e.stopPropagation()不会取消自身注册的冒泡阶段的事件处理程序响应！！！会触发；而想要在自身同时存在冒泡和捕获的时候取消第二次事件处理程序响应，需要通过e.stopImmediatePropagation()阻止任何事件处理程序被调用。（这也是这2个API的区别） 为什么我们通常在冒泡阶段调用处理程序？ 因为在跨浏览器的事件处理程序中，因为IE只支持冒泡，为了保证事件处理代码在大多数浏览器下一致性的运行的目的。所以事件处理程序被调用的时机也就只关注 冒泡阶段了。 事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。这里可能存在疑问：我们把事件处理程序挂在父级元素上，如何在处理程序中去操作子元素？ 一般挂在子元素中，我们明确知道this指向的就是子元素，即操作我们的目标元素，那么在父元素中如何操作子元素呢？不得不提的e.target 属性,这个属性会返回事件触发的目标元素，注意这个目标元素一定是唯一的！举例来说：document，parent，child，点击了parent区域就一定是parent，点击了child区域就一定是child，而不会像事件流那样的既是child，也是parent！！！ 注意：这里再次说明了事件流不是毫无目的 的“随意流”，而是流到事件的目标元素。 123456789101112131415161718192021222324252627282930313233343536e.target 类型 Element&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 把事件处理挂在父元素上， parent.addEventListener('click',function(e) &#123; alert(e.target.id); let _this = e.target; // 获取到目标元素，也就是事件实际的目标 &#125;,false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情，就像老板一下命令，各自员工做自己岗位上的工作去了。之前分别给parent，child注册的click事件，就是同一事件各自响应各自的处理程序。 事件冒泡的意义以及应用事件委托：只指定一个事件处理程序，就可以管理某一类型的所有事件。 原理：利用事件冒泡机制，给父元素绑定事件处理程序并指定事件处理程序的响应阶段为冒泡阶段，这个时候点击子元素，由于子元素没有事件处理程序，所有没有任何反应，但是事件流会继续向上冒泡，也就是冒泡到父元素，父元素有处理程序，并且父元素可以知道实际上事件发生时的目标元素——通过e.target =&gt; 这个是核心 核心： 通过e.target可以确定实际触发的目标元素 好处：前者少了一个遍历所有li节点的操作，所以在性能上肯定是更优的；其次当我们绑定完事件以后又动态添加了一些元素，这时候如果是给每个子元素绑定事件，那么为了效果，我们还要为新添加的子元素绑定一次事件，重复操作且代码冗余。 event对象为什么这么重要呢？因为event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样（原生事件直接封装好）。 关于currentTarget和target属性对象this始终等于currentTarget的值，而target的值只包含事件的实际目标。（触发事件的实际目标） 如果直接将事件处理程序指定给目标元素，则this，currentTarget，target包含相同的值。差异体现在冒泡上。 自定义事件和DOM中的事件模拟DOM中的事件模拟1234567891011121314151617181920// step1:创建event对象var event = document.createEvent(&#123;string&#125;) // 该方法创建一个event对象，该方法接收一个参数，表示创建的事件类型的字符串（指定好的），所以字符串在DOM2级中使用复数形式，而在DOM3级中使用了单数形式，这也是为什么有s和没s没区别的原因。// step2:初始化事件event.initEvent(eventName, canBubble, preventDefault) // 分别表示事件名称，是否可以冒泡，是否阻止事件的默认操作。 // step3:设置事件发生时的参数event.target = this;event.message = 'sr';...根据不同的实际需求设置// step4: 绑定到DOM元素上，此时这个事件就跻身“官方事件”$(dom).addEvent(eventName,function() &#123; alert('hahahaha')!&#125;, false);// step5: 触发事件$(dom)dispatchEvent(event) // 所有支持事件的DOM节点都支持这个方法。调用dispatchEvent（）方法时，需要传入一个参数，即表示要触发事件的event对象。 所以综上：DOM中的事件模拟，包括 创建一个指定类型的事件实例 初始化事件：事件名称，是否冒泡，是否阻止事件的默认行为 设置事件对象的属性（模拟那些已有的，可以在事件处理程序中通过传参获得） 注册事件 触发事件 如何理解触发事件？对于dispatchEvent触发的理解——任何点击、各种交互其实都只是形式，形式内在也是封装了dispatch（）罢了 为什么要模拟DOM事件？大部分事件本身是由用户交互来触发的，但是有些时候我们想让程序自己来触发事件，这个时候就需要手动调用函数来实现触发事件，并传入参数event，作为当这个事件触发时传递出去的信息。 有什么用?这个触发事件的机制由我们自己来决定了，我们可以设置自己的条件逻辑 eg： 123if(...) &#123; Element.dispatchEvent(e)&#125; 然后对这个事件有监听的DOM元素就会被监听到，此时事件处理程序响应。 补充如果是模拟一些比较复杂的DOM事件，比如鼠标事件，官方提供了很多事件对象的属性，用于在模拟的鼠标事件发生时传递一些信息：包括元素相对于屏幕，视口的坐标等… 自定义事件 自定义事件的本质：观察者模式 基于原生事件，触发依赖于原生事件的触发机制 自定义事件没有浏览器帮你，需要自行设置触发 为什么要有自定义事件？站在一个更高的层次上进行封装和对客观世界的描述，比如我们会说 点击盒子触发xx事件，而不会说点击某个div，btn这样的DOM节点 优点：跳出原生事件的限制，提高了封装的抽象层级 对比原生事件：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 historyAPI]]></title>
      <url>%2F2017%2F08%2F08%2FHTML5-historyAPI%2F</url>
      <content type="text"><![CDATA[源起学习webpack使用的时候，写简单SPA应用时需要通过pushState API变更历史URL，并加载页面 是什么？访问历史记录 123456789101112131415/* * description: 向历史记录里添加一条历史记录，此时地址栏发生变化，历史记录里添加了一条状态，但是页面并不会刷新也不会跳转，！！！注意此时新增的状态为当前通过pushState添加的，而历史记录里的是之前的状态被压栈 * summary: 存储当前状态 * @param: &#123;Object&#125; state state为一个对象或者null，称为状态对象。这个对象可以拿来记录当前URL所对应的一些信息，状态对象由pushState创建，在popstate事件触发的时候通过e.state拿到，总而言之，它存储JSON字符串，可以用在popstate事件中。 * @param &#123;String&#125; title title为页面的标题，但当前所有浏览器都忽略这个参数，传递一个空字符串是安全的做法。当然，你可以传递一个短标题给你要转变成的状态。 * @url &#123;String&#125; url url则为新历史记录的地址，不写则为当前页，请注意，浏览器在调用pushState()方法后不会去加载这个URL，并且这个地址和当前页必须是同源的 */history.pushState(state, title, url)// 参数同上history.replaceState(state, title, url)相关事件：popstate何时触发？当历史记录条目发生更改时，注意这个更改指的是点击了浏览器历史记录的前进/后退或者是调用history.back()/history.go()/history.forward()时。需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。而popstate事件的state属性就是历史状态对象的副本。 有什么用？界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态，在HTML5可以通过window.history操作访问历史状态，让一个页面可以有多个历史。 为什么会有？假设一个学生管理系统的记录的页面，然后我们需要把这个页面学生违纪的内容发送给他人，但是如果仅仅只是一个tab栏切换，我们发送URL地址就会有一个尴尬的现象，就是发过去的又是初始化的页面（也就可以理解为：无状态），因为URL地址至始至终没有发生变化过。 简单来说就是动态加载出来的内容我们无法给别人分享链接。这种对状态的需求在应用开发中尤为迫切！！！ 因为AJAX的兴起，前端走向了web应用的时代，利用AJAX动态加载实现内容替换。但是弊端是利用AJAX实现无刷新改变的文档内容，是不会修改URL的，但是这里有人要问为什么一定要修改URL呢？因为一个URL代表一个特定的网络资源，AJAX修改了页面的内容，所以用不同的URL去标识他们，这个是非常有必要的。 这种状态思想特别是在现在web开发（web应用）中是非常重要的。 以前的history有什么？之前我们可以通过history对象实现前进，后退，和刷新之类的操作 1234history.length; // 历史堆栈中的记录数history.back(); // 后退history.forward(); // 前进history.go([delta])：delta是个数字，如果不写或为0，则刷新本页；如果为正数，则前进到相应数目的页面；若为负数，则后退到相应数目的页面。 demo1—基本用法和效果12345678910 window.onpopstate = function(event) &#123; alert("location: " + document.location + ", state: " + JSON.stringify(event.state));&#125;;history.pushState(&#123;page: 1&#125;, "title 1", "?page=1"); // 添加一条状态，此时地址栏变为url+"?page=1"，之前的入口页被压入历史记录history.pushState(&#123;page: 2&#125;, "title 2", "?page=2"); // 添加第二条状态，此时上一个状态被添加到历史记录，此时历史记录里应该有两个状态// history.replaceState(&#123;page: 3&#125;, "title 3", "?page=3");history.replaceState(&#123;page: 3&#125;, "title 3", "http://www.baidu.com"); // [1] 替换当前状态信息，此时因为没有添加，所以历史记录里还是两条状态信息// history.back(); // [2] alerts "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;" 通过结果可以看出replaceState只是替换了当前状态而不是替换当前，追加之前到历史栏// history.back(); // [3] alerts "location: http://example.com/example.html, state: null 通过结果可以看出当第二次回退，实际上回到了最初的入口页，这个状态在页面载入，脚本执行后就被放入了历史记录里// history.go(2); // [4] alerts "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125; 通过结果可以看出page2确实被page3替换掉了 对pushState的误解 一开始误认为pushState会直接向地址栏加入我们通过调用pushState()添加的状态，而pushState()其实是改变了当前状态，把当前状态前一个状态添加到历史记录。 源自张鑫旭老师的historyAPI demo配合ajax技术实现的PJAX技术 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152JS代码：// 获取元素，绑定事件，获取查询参数var eleMenus = $("#choMenu a").bind("click", function(event) &#123; var query = this.href.split("?")[1]; if (history.pushState &amp;&amp; query &amp;&amp; !$(this).hasClass(clMenuOn)) &#123; /* ajax载入~~ */ // history处理 var title = "上海3月开盘项目汇总-" + $(this).text().replace(/\d+$/, ""); document.title = title; if (event &amp;&amp; /\d/.test(event.button)) &#123; history.pushState(&#123; title: title &#125;, title, location.href.split("?")[0] + "?" + query); &#125; &#125; return false;&#125;);//var fnHashTrigger = function(target) &#123; var query = location.href.split("?")[1], eleTarget = target || null; if (typeof query == "undefined") &#123; if (eleTarget = eleMenus.get(0)) &#123; // 如果没有查询字符，则使用第一个导航元素的查询字符内容 history.replaceState(null, document.title, location.href.split("#")[0] + "?" + eleTarget.href.split("?")[1]) + location.hash; fnHashTrigger(eleTarget); &#125; &#125; else &#123; eleMenus.each(function() &#123; if (eleTarget === null &amp;&amp; this.href.split("?")[1] === query) &#123; eleTarget = this; &#125; &#125;); if (!eleTarget) &#123; // 如果查询序列没有对应的导航菜单，去除查询然后执行回调 history.replaceState(null, document.title, location.href.split("?")[0]); fnHashTrigger(); &#125; else &#123; $(eleTarget).trigger("click"); &#125; &#125; &#125;;if (history.pushState) &#123; window.addEventListener("popstate", function() &#123; fnHashTrigger(); &#125;); // 默认载入 fnHashTrigger();&#125; 使用pushState实现有状态的tab栏切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;History Api&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; overflow: hidden; margin: 0; padding: 0; &#125; aside &#123; background-color: #ccc; width: 220px; float: left; height: 100%; &#125; aside ul &#123; font-size: 20px; line-height: 2; &#125; aside ul li &#123; cursor: pointer; &#125; article &#123; background-color: #f5f5f5; margin-left: 220px; padding: 20px; height: 100%; overflow: scroll; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;aside&gt; &lt;ul id="list" data-id="1" data-name="sss"&gt; &lt;/ul&gt; &lt;/aside&gt; &lt;article&gt; &lt;p id="content"&gt;&lt;/p&gt; &lt;/article&gt; &lt;!-- plugin:auto file name --&gt; &lt;script src="data.js"&gt;&lt;/script&gt; &lt;script&gt; (function() &#123; var listElement = document.querySelector('#list'); // 遍历数据并渲染到页面 for (var title in data) &#123; var liElement = document.createElement('li'); liElement.innerHTML = '⭐️' + title; liElement.setAttribute('data-title', title); listElement.appendChild(liElement); &#125; var liElements = document.querySelectorAll('#list&gt;li'); var content = document.querySelector('#content'); // 注册每一个元素事件，点击时保存当前状态 for (var i = 0; i &lt; liElements.length; i++) &#123; liElements[i].addEventListener('click', function() &#123; // 拿到被点击title var title = this.dataset['title']; // 赋值 content.innerHTML = data[title]; // 操作历史记录 if (window.history &amp;&amp; history.pushState) &#123; // 添加一个新的历史记录 history.pushState(title, 'title没有任何浏览器支持', '?t=' + title); &#125; else &#123; console.log('不支持'); &#125; &#125;); // 当我们在伪造的访问历史中前进或后退时会执行一个popstate事件 window.addEventListener('popstate', function(e) &#123; // 回退时根据保存的状态渲染页面内容 content.innerHTML = data[e.state]; &#125;); // window.location = "https://www.baidu.com"; // 第一次请求过来 获取地址栏中的t参数 // window.location可以拿到当前网页中跟地址相关的信息 var search = window.location.search; // ?t=jkaljdksfla // 如果地址栏中的地址有中文，会以URL编码方式呈现 // decodeURI 可以转换到之前中文 var title = search.split('=')[1]; // ['?t','jkaljdksfla'] if (title) &#123; // 有值 decodeURI作用就是从URL编码转换到之前的状态 console.log(decodeURI(title)); content.innerHTML = data[decodeURI(title)]; &#125; &#125;)(); &lt;/script&gt; 此例子最大的效果在于：保存了状态，当把URL发送给别人的时候，得到的是一个带有状态的视图，而不是初始化页面。 参考： popstate·MDN ajax与HTML5 history pushState/replaceState实例·张鑫旭 PJAX的实现与应用·小胡哥]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解JavaScript作用域]]></title>
      <url>%2F2017%2F05%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[关键词: 作用域 定义时 变量查找规则 赋值操作基于作用域查找规则 查找目标的值也是基于作用域查找规则 作用域规则JavaScript作用域是定义时的概念，用于确定在何处以及如何查找变量（标识符），如果是对变量的赋值操作就会进行LHS查询，如果是获取变量的值就会进行RHS查询。 深入理解”定义时”概念两个函数唯一的区别：在于函数体内部的变量x是否用var重新声明. 当使用默认参数的时候，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失。 12345678910111213141516171819例1：var x = 1;function foo(x, y = function() &#123; x = 2&#125;) &#123; var x = 3; y(); console.log(x);&#125;foo(); // 3x; // 1----------------------------------------------例2：var x = 1;function foo(x, y = function() &#123; x = 2&#125;) &#123; x = 3; y(); console.log(x);&#125;foo(); // 2x; // 1 代码的执行过程：参数初始化过程和函数体代码执行过程 对于例1很容易得出错误的结果foo(); // 3 x; // 1 错误的原因就是：对于作用域是定义时概念理解得不深刻。 123456789101112参数初始化过程：1.形成一个独立的作用域，当不传递参数y时，使用默认参数值进行初始化&#123; let x; let y = function() &#123;x = 2 &#125;;&#125;2.代码执行的过程var x = 3; // 用var重新声明了和参数同名的变量x，则此时参数x被覆盖，变量x和参数x不是同一个xy(); // 函数调用，对变量x进行赋值操作，这时最容易出错的地方 // 因为y函数内部并没有变量x，则对外层的变量x进行赋值，关键是对哪一个外层的x进行赋值？ // 这里很容易理解成调用时函数y的外部x进行赋值，这个时候就把定义时的概念没有理解清楚。 // 而真实的是此时对参数作用域中的x进行赋值，但因为参数x和变量x不指向同一个x，而函数体内使用的是变量x，所以赋值操作没有生效。 对于例2,因为没有用var重新声明一个同名变量，此时函数体内的x指向参数x，y赋值操作的目标也是参数x，两个x是同一个x，所以y()赋值成功。 关于为什么会错误理解因为时常弄混淆静态作用域和动态this 动态作用域JavaScript中的作用域是词法作用域 词法作用域是一套关于引擎寻找变量以及会在何处找到变量的规则。词法作用域最最最最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval()或with） 动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式。 123456789101112function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2. 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。动态作用域的查找结果导致a为3. 简单总结区别 词法作用域是在写代码的时候或者说定义时确定的，而动态作用域是在运行时确定的，（this也是！） 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript函数的设计]]></title>
      <url>%2F2017%2F05%2F18%2FJavaScript%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[JavaScript函数设计关键词: 黑匣子 抽象 封装 参数个数检查 参数类型检查 函数的核心理念——抽象和封装过程封装过程：指的是用户只需知道函数名，如何正确的传递参数以及返回值就够了，而内部的逻辑用户无需知道。 抽象：借助抽象，我们才能不关心底层具体的实现/计算过程，而直接在更高层上思考问题。 而函数就是抽象的方式，一个函数就是一个一个完整的行为，函数体内部的语句在执行的时候，函数内部通过条件判断和循环就可以完成非常复杂的逻辑。 函数的执行过程输入（传参）——计算/处理 ——输出（返回结果，如果有） 函数就是一段完整的代码，函数在执行的过程中，如果没有return语句（函数结尾如果没有return语句就是隐含 return undefined）,控制权无法交回被调用的代码。一旦执行到return时，函数就执行完毕，并将结果返回。 ES6中的Generator函数除外，Generator函数的yield类似return，可以返还控制权。 JS中的函数 JavaScript中函数定义参数时没有指定参数的数据类型 JavaScript中的函数不会对参数arguments进行类型检查 JavaScript中的函数不会对arguments进行个数检查 JavaScript中函数没有重载 对比JAVA的函数123public String getRecord(int key) &#123; return db[key]; 修饰符public修饰了函数getRecord的可访问性 String说明了存在返回值并且说明了返回值类型 int key说明了参数类型和参数名字 JAVA函数的定义1、支持重载 2、定义函数时就可以看到函数的访问性（访问控制修饰符） 3、定义函数时就可以看到函数的返回值类型 4、定义函数时就可以看到函数的参数类型 对比Python函数调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt;abs(1, 2)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' Python函数调用1、拥有对参数个数检查的机制 2、拥有对参数类型检查的机制 集百家所长编写健壮的JS函数因为js函数没有对实参进行检查的机制,所以我们编写函数就要自己模拟实现这些机制 从Python中得到的感悟首先，对参数的个数进行检查 利用arguments参数判断实际传入参数的个数,这也就是说即使函数没有定义参数，也可以拿到参数的值，也是很多js库常使用的手段 实现：可选”参数” 123456// 接收2-3个参数，参数b是可选参数，如果只传2个值，b默认为nullfunction abc(a, b, c) &#123; if(arguments.length === 2) &#123; //实际拿到的是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 其次，检查参数的数据类型 使用条件判断的方式判断参数的是否传递，以及参数是否是期望的值 12345678910function log(x, y) &#123; if(typeof y !== 'string') &#123; //检测参数的数据类型 y = 'World'; &#125;&#125; console.log(x, y);log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 从JAVA中得到的感悟JAVA中的函数从函数的定义就可以看到函数的参数类型，是否有返回值和返回值类型 所以为了编写可维护的JavaScript函数，我们可以利用注释和规范的命名实现对函数的描述。 利用函数名描述函数的功能 利用参数名描述参数是什么，利用注释描述参数的数据类型 利用返回值描述结果是什么，利用注释描述返回值的数据类型 或者写一段完整注释包括：描述函数的目的，功能，参数和参数类型，返回值和返回值类型 模拟函数重载函数重载：函数名相同，参数的个数和类型不同，实现不同的功能。 模拟重载：利用条件判断判断参数的个数和参数的类型，来实现重载。 参考： 廖雪峰·Python教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包中使用this存在的问题]]></title>
      <url>%2F2017%2F05%2F16%2F%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8this%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[闭包中使用this存在的问题关键词: 闭包 函数声明时 函数运行时 词法作用域 特殊变量 箭头函数 前言也是为什么老是有var that = this;的写法以及箭头函数产生的原因。 闭包中使用this的问题在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。 12345678910111213//在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。// 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; return function() &#123; //闭包 return this.name; //在闭包中使用this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 Window 为什么this会指向undefined呢？这是因为每个函数在调用的时候都会自动取得两个特殊的变量，this和arguments，内部函数在搜索这2个变量的时候，只会搜索到其活动对象为止，因此永远不可能访问到外部函数中的这2个变量。 那么如何访问到这两个变量呢？把外部作用域中的this保存到一个闭包能访问到的变量里，并在闭包中引用那个变量，而不是引用this常见的 12var this = that;var args = Array.prototype.slice.call(arguments); 上例的修改后： 12345678910111213var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; var that = this; //修改：保存外部作用域的this到一个闭包能访问到变量中 return function() &#123; //闭包 //return this.name; //在闭包中使用this return that.name; //修改：在闭包中通过引用that来引用外部作用域的特殊变量this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 this指向Window ES6的箭头函数：ES6的箭头函数最佳的使用姿势就是解决this指向问题。因为在JavaScript中，对象之间的调用是非常繁杂的，一不小心遇到this被篡改的问题，导致后面的代码出错： 比如 1234567891011121314class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(function() &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); //undefined says hi 这是一个比较经典的this被篡改的问题，因为这个setTimeout函数，他的this指向window对象。 我们可以利用一个变量保存住这个this指针，也或者使用bind(this)方法，但有了箭头函数，等于函数本身集成了保存this指针的功能，这让我们不是处处提防this陷阱。同样的，基于这个原因，箭头函数中没有自己的this，但当你在箭头函数内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的 this。 箭头函数最常用于回调函数，如事件处理器或定时器中12345678910111213141516171819202122232425262728class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(() =&gt; &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); // animal says hi//等价于class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; var that = this; setTimeout(function() &#123; console.log(that.type + ’says’ + say); &#125;, 1000); &#125;&#125; 对箭头函数的误解 最大的误解：箭头函数使用的是外部函数（这里理解成父函数）的this 是否局部（Lexical）？12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;,100);&#125;foo.call( &#123; id: 42 &#125; );// id: 42 这里的 =&gt; 箭头函数看起来把它内部的this绑定为父函数 foo() 里的 this。如果这个内部函数是一个常规的函数（声明或表达式），它的 this将类似 setTimeout如何调用函数一样被控制着。 但是实际上是箭头函数内部根本没有this变量，对于this变量的访问变量就像根据词法作用域查找一般变量一样,查找到有this变量的外层作用域，而不是父级作用域。 箭头函数的注意1）箭头函数 =&gt; 所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去”, 虽然 =&gt; 箭头函数没有一个自己的 this，但当你在内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的this。 123456789101112function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;; &#125;; &#125;;&#125;foo.call( &#123; id: 42 &#125; )()()();// id: 42 有多少次 this 的绑定执行了呢？大部分人会认为有4次——每个函数里各一次。 事实上更准确地说，只有一次才对，它发生于 foo() 函数中。 这些接连内嵌的函数们都没有声明它们自己的 this，所以 this.id 的引用会简单地顺着作用域链查找，一直查到 foo() 函数，它是第一处能找到一个确切存在的 this 的地方。 说白了跟其它局部变量的常规处理是一致的！ 换句话说，正如同 Dave 说的一样，this 生来局部，而且一直都保持局部态。=&gt;箭头函数并不会绑定一个 this 变量，它的作用域会如同寻常所做的一样一层层地去往上查找。 2)不仅仅是this 如果你贸贸然地同意了“箭头函数就是常规function的语法糖”这样的观点，那是不正确的，因为事实并非如此——箭头函数里并不按常规支持 var self = this 或者 .bind(this) 这样的糖果。 那些错误的解释都是典型的“给对了答案却讲错了原因”，就像你在高中代数课的测试上明明写对了答案，但老师仍会画圈圈告诉你用错方法了——如何解得答案才是最重要的！ 另外，关于“=&gt;箭头函数不绑定自身的 this，而允许局部作用域的方案来沿袭处理之”的正确描述，也解释了箭头函数的另一个情况——它们在函数内部不走寻常路的孩子不仅仅是 this。 事实上 =&gt;箭头函数并不绑定 this，arguments，super(ES6)，抑或 new.target(ES6)。 这是真的，对于上述的四个（未来可能有更多）地方，箭头函数不会绑定那些局部变量，所有涉及它们的引用，都会沿袭向上查找外层作用域链的方案来处理。 12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log("args:", arguments); &#125;,100);&#125;foo( 2, 4, 6, 8 );// args: [2, 4, 6, 8] 这段代码中，=&gt;箭头函数并没有绑定 arguments，所以它会以 foo() 的 arguments 来取而代之，而 super 和 new.target 也是一样的情况。 3）this在箭头函数中被绑定，4种绑定规则中的无论哪种都无法改变其绑定 4）箭头函数不可以当作构造函数，也就是不可以使用new命令，否则会报错 最后虽然箭头函数可以把作用域和this机制联系起来，但是却容易混淆，使代码难以维护。应该在作用域和this机制中二选一，否则就会造成混淆。要么只使用词法作用域，要么只使用this机制，必要时使用bind()。尽量避免使用that=this和箭头函数共同使用。 参考： ES6 箭头函数中的 this？你可能想多了（翻译） ECMAScript 6 入门-箭头函数 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解JavaScript中对象内容的访问方式]]></title>
      <url>%2F2017%2F05%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[整理一下对象访问两种方式的区别以及持续更新不同的使用场景 对象内容的访问的两种方式： . 操作符：通常称为“属性访问” [ ] 操作符：通常称为“键访问” 属性访问和键访问的异同相同实际上它们访问的是同一个位置，并且会返回相同的值 区别 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。 . 操作符后面总是字符串，所以为对象增加属性的时候使用点语法，会自动把属性名称转为字符串， 举例： 1.如果要引用名称为 “Super- Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效 的标识符属性名。 2.使用Symbol值作为对象的属性名时只能使用 [ ] 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 123456789101112131415161718var mySymbol = Symbol();//第一种写法var o = &#123;&#125;;o.mySymbol = 'Hello';//第二种写法var o = &#123;&#125;;o[mySymbol] = 'Hello';//第三种写法var o = &#123; [mySymbol]: 'Hello!'&#125;;// 第四种写法var o = &#123;&#125;;Object.defineProperty(o, mySymbol, &#123; value: 'Hello!' &#125;); 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意：第一种写法是不会读取mySymbol作为标识符所指代的那个值的，因为点语法后面总是字符串，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 123o.mySymbol = 'Hello!';o[mySymbol] // undefinedo['mySymbol'] // "Hello!" 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 [ ] 使用场景1.可计算属性名 2.Symbol值作属性名 3.需要使用变量方式遍历属性 4.函数传参，参数作属性名，或者属性名的一部分，只能使用 [ ] 5.使用对象法进行数组去重，对象的键是一个变量 参考：ECMAScript6 入门——Symbol]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运算符]]></title>
      <url>%2F2017%2F05%2F10%2FJavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[相关关键词 表达式 优先级 结合性 执行顺序 求值顺序 JavaScript运算符 也叫操作符，英文：operator，关于运算符，除了都知道的优先级，还要知道Associativity JavaScript中的运算符大多由标点符号表示，少数由关键字表示，每一个运算符具有不同的行为，运算符始终都遵循着一些固定语法。一些运算符可以作用于任何数据类型， 但仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回一个特定类型的值，在下面的运算符规则表中，箭头前为运算符操作数的类型，箭头后为运算结果的类型 分类 JavaScript的运算符总共有59个，如果根据其操作数的个数进行分类，分为一元运算符，二元运算符，三元运算符。而它们的目的都是一致的: 将一个到多个表达式合并为一个表达式 优先级和结合性 运算符优先级控制着运算符的执行顺序，优先级高的运算符的执行总是先于优先级运算符低的运算符——————错误的理解 修正：不同操作相邻出现的时候，表达式是作为左操作符的后操作数呢？还是作为右操作符的前操作数呢？=&gt;这就是操作符优先级干的事 对优先级错误的理解： 认为拿到一行语句，先按照操作符的优先级划分，找到最高优先级的操作符，先求值。 所以就对 baz&amp;&amp; fn()这样的代码存在困惑，因为如果这么理解的话，fn()的优先级最高，那么无论如何都会先执行 fn()再去 &amp;&amp; 判断，可实际的是 &amp;&amp;判断前面的baz是否存在而决定是否执行后面的fn()，此时发生冲突。但实际上所谓的优先级是指操作数结合操作符，优先结合。即同一个操作数被左右两个操作符共同使用的时候，此时这个操作数并不会被两个操作符共同使用，而决定它被谁使用的依据就是操作符的优先级。不是说谁的优先级高就先给谁求值。 简单一点的说，所谓的优先级就是加个括号,而优先级和结合性就是决定括号怎么加 那么何时求值？比如 d = a + (b+c) 对表达式d求值，首先对表达式a求值，返回；然后要对 + 后的一个表达式求值，此时 + 后面的表达式结果依赖于b + c，此时b + c才开始求值，因为最终的结果依赖b + c 的结果，所以才有了求值。 所以像短路运算符 &amp;&amp; 和 || 一起出现的时候，因为&amp;&amp;的优先级要比||高，所以&amp;&amp;优先结合操作数（但是并不意味着要立即求值，还是要根据从左往右的顺序，先对第一个操作数求值。剩下的，有依赖有需求才会求值。） 所以千万不要再理解成优先级高，优先求值 优先级是怎么产生的？1234567891011121314例1：var a =42, b;b = (a++, a);a; //43b; //43如果去掉括号会怎么样？var a=42, b;b = a++, a;a; //43b; //42 【1】注意： b的结果不一样了，上面代码发生了什么？说明了什么？ 原因就在于,运算符的优先级比=低,当不同操作相邻（, =）出现时，表达式a++是作为=的后操作数呢？还是作为,的前操作数呢？ =&gt;操作符的优先级工作了 =&gt;因为=&gt;的优先级高于, =&gt;原式&lt;=&gt;(b = a++), a; =&gt;此时a++后自增，先返回值，所以表达式b的值是42 1234简单的例2：fn01() || fn02 &amp;&amp; fn03();//等价于fn01() || (fn02 &amp;&amp; fn03()); // &amp;&amp; 优先级高于 || fn02结合&amp;&amp; 1234567891011121314151617181920212223242526例3：var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;分析：1.先解决优先级问题=&gt;哪里发生了优先级问题？ a b c c b c b a (看操作数两边的符号，除了第一个操作数和最后一个操作数以及三元表达式 ? a :都会发生优先级问题)2.再来一遍，a发生优先级问题，看表达式a的左边和右边，&amp;&amp; 高于 = =&gt; a 作为&amp;&amp;的前操作数3.再看表达式b，b发生优先级问题，看表达式b的左边和右边,&amp;&amp; 高于 ||=&gt; b 作为&amp;&amp;的后操作数=&gt;var d = (a &amp;&amp; b) || c ? c || b ? a : c &amp;&amp; b : a;//...重复以上步骤，得出以下结果=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;做到这一步无法往下做了，可以看成e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;此时仅有优先级已经无法满足求值的需求了。--------------- ---------------- Associativity（结合性） 如果所有操作符优先级一样，结合性决定了执行结果的唯一性。 结合性是怎么起作用的？当表达式相邻的操作符具有相同的优先级时，优先级已经不能决定表达式最终结果的时候，结合性就起作用了。 12345678910111213141516171819202122回到之前例子没有解决的问题：=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;这里没有可能性二//可能一e ? (f ? a : g) : a; true --- a / true --- (f ? a : g) / \false --- ge \ false --- a 结合性解决了什么问题？ 当优先级一样的时候括号怎么加 1a OP b OP c 左结合性（从左到右）意味着它被处理为(a OP b) OP c，而右结合性（从右到左）意味着它被解释为a OP (b OP c)。而对于以下代码右结合性是正确的，所以你可以写： 1234567891011a = b = 5;分析：对于表达式b，左边和右边是相同的操作符，优先级一样的。所以优先级已经无法解决这种情况下的执行结果了。显然，如果只有优先级的话，a = b = 5; //可能性1(a = b) = 5;//可能性2a = (b = 5);但是由于(a = b) = 5中，(a = b)的结果并不是一个变量，而是一个返回表达式a赋值后的结果2，因此它不能出现在等号的左边！所以以上最终的执行结果只有可能是可能性2 那么： 12345678910111213141516171819202122232425262728293031323334a?b:c?d:e//可能性一(a?b:c)?d:e true --- d / true --- b / \ a false --- e true --- d / \false --- c \ false ---e =&gt; a 执行结果 d || e //可能性二（因为三元表达式右结合）a?b:(c?d:e) true --- b / a true --- d \ / false --- (c?d:e) \ false ---e =&gt; a 执行结果 b || d || e 结果不唯一了，所以结合性干的事就是确保结果的唯一性。 这个要怎么算？先看优先级，两个一样。再看结合性，右结合，所以：先算c?d:e再算 a?b:（c?d:e） 这就是所谓右结合。如果是左结合的话 就是先算a?b:c再算 （a?b:c）?d:e实际上，一般结合性的问题都可以用括号来解决。 先要考虑优先级，有相同优先级的就看结合性以决定括号的添加方式。结合性决定处理相同优先级的运算符的顺序 或者说为什么结合性不同影响着执行结果？？？ 因为表达式可能会产生副作用，比如函数调用: 1var a = foo() &amp;&amp; bar(); 这里foo()会首先执行，它的返回结果决定了bar()是否执行。所以如果bar(）在foo（）之前执行，整个结果完全不同。 如何更好理解操作符的结合性？？？ 想象一下，什么情况下 AB 不等于 BA 矩阵（不考虑单位矩阵的情况下） 执行顺序 执行顺序是不变的，总是从左到右。优先级和结合性并没有影响代码的执行顺序，也无法影响，它们做的是改变了表达式的求值顺序，注意 执行顺序 != 求值顺序 1234567891011121314151617181920var a=1;b=(a=3)+a++;这个例子中运算顺序是这样的1.计算b2.a＝33.a++(设为c)4.计算a（这时候a变成了4已经，不是再最后才变得，但表达式使用的是a++的结果c，也就是a原来的值）5.计算3+c6.把3+c赋值给b = / \ b + / \ = ++ / \ / a 3 a 深入浅出优先级，结合性，执行顺序，求值顺序 代码执行顺序是永远不变的，从左往右执行。 而优先级和结合性是如何添加括号的依据，表达式越先求值的说明离AST根节点越远，为什么？先求值的说明依赖少，有依赖的还得继续向下遍历。 什么是左值(Left-hand-side expressions) Left values are the destination of an assignment. 左值指的是赋值操作的目标，也就是能出现在赋值表达式左边的表达式，自定义的函数不能返回左值是ECMAScript的规范。 那么什么类型的值可以出现在赋值表达式的左侧呢？变量对象属性数组元素 运算符总结（持续更新） 运算符总结 优先级 运算符 操作 结合性 类型 20 ( … ) 分组 N/A N/A 19 … . … 成员访问 l-to-r 19 … [ … ] 成员访问 l-to-r N/A 19 new … ( … ) 有参构造 N/A N/A 18 … ( … ) 函数调用 l-to-r N/A 18 new … new.target操作符检测是否用new操作符调用函数/构造函数 r-to-l new.target=&gt;undefined/ 在类构造函数中，new.target指的是直接调用的构造函数new。 17 … ++ 后自增 N/A N/A 17 … – 后自减 N/A N/A 16 ! … 逻辑非 r-to-l bool-&gt;bool 16 ~ … 按位求反 r-to-l 16 + … 一元加(注意区别于二元加) r-to-l any=&gt;num 16 - … 一元减(注意区别于二元减) r-to-l any=&gt;num 16 ++ … 先自增 r-to-l 属于算术运算符，操作lval 16 – … 先自减 r-to-l 属于算术运算符，操作lval 16 typeof … 判断类型 r-to-l any=&gt;str 16 void … 返回空 r-to-l any=&gt;undefined 16 delete … 删除属性 r-to-l lval-&gt;bool 15 … … 幂运算 r-to-l any,any=&gt;num，求幂前会发生类型转换num 14 … * … 求积 l-to-r any,any=&gt;num，求积前会发生类型转换num 14 … / … 求商 l-to-r any,any=&gt;num，求商前会发生类型转换num 14 … % … 取余 l-to-r any,any=&gt;num，求商前会发生类型转换num 13 … + … 求和/拼接(考虑类型转换) l-to-r any,any=&gt;any 13 … - … 求差(考虑隐式转换） l-to-r any,any=&gt;num 12 … &lt;&lt; … 按位左移 l-to-r 12 … &gt;&gt; … 按位右移 l-to-r 12 … &gt;&gt;&gt; … 无符号右移 l-to-r 11 … &lt; … 小于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &lt;= … 小于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt; … 大于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt;= … 大于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … in … 测试属性 l-to-r str,obj=&gt;bool 11 … instanceof … 测试对象类(含原型链) l-to-r obj,fn=&gt;bool 10 … == … 测试相等 l-to-r any,any=&gt;bool 10 … != … 测试不等 l-to-r any,any=&gt;bool 10 … === … 测试严等 l-to-r any,any=&gt;bool 10 … !== … 测试严不等 l-to-r any,any=&gt;bool 9 … &amp; … 按位与 l-to-r 8 … ^ … 按位非 l-to-r 7 … | … 按位或 l-to-r 6 … &amp;&amp; … 逻辑与（操作数选择器） l-to-r any,any=&gt;any 5 … || … 逻辑或（操作数选择器） l-to-r any,any=&gt;any 4 … ? … : … 三元表达式 r-to-l bool,any,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … += … 运算且赋值 r-to-l lval,any=&gt;any 3 … -= … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … /= … 运算且赋值 r-to-l lval,any=&gt;any 3 … %= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &lt;&lt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &amp;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … ^= … 运算且赋值 r-to-l lval,any=&gt;any 3 … |= … 运算且赋值 r-to-l lval,any=&gt;any 2 yield … 暂停当前gen函数执行，返回表达式的值给gen函数的调用者 r-to-l any=&gt;any 2 yield … 用于在一个gen函数中调用另一个gen函数 r-to-l AnoFn*()=&gt;any 1 … … 展开运算符 r-to-l array=&gt;any 0 , … 忽略第一个操作数，返回第二个操作数 r-to-l any,any=&gt;any 注： l-to-r : left-to-right 左结合 r-to-l : right-to-left 右结合 lval : leftValue 左值 in右侧必须是一个对象。例如，您可以指定使用String构造函数创建的字符串，但不能指定字符串文字。in操作符会检测原型链上的属性。使用delete操作符删除属性，则操作in员返回false该属性。如果将属性设置为undefined但不将其删除，则in该属性的操作符返回true。 instanceof操作符会检测原型链。 关于–,++操作符报错“ReferenceError: Invalid left-hand side expression in postfix operation” ，这里报的是引用错误，其实想想应该可以这么理解因为++ 和 –操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪返？-&gt;肯定需要一个容器，这个容器就是左值. 123456789101112131415161718192021222324252627// ++ --操作符对操作数有要求吗？是不是只能操作左值?//Invalid left-hand side expression in postfix operationvar str = 'abc';console.log(str++); // NaN 说明可以操作字符串//console.log(5++);//ReferenceError: Invalid left-hand side expression in postfix operation 说明不能直接操作值//引用错误：出现这个的原因是因为++ 和 --操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪放？-&gt;需要一个容器 （因为值是不可变的)var o = &#123;&#125;;console.log(o++); // NaN 说明可以操作对象var b;console.log(b++); //NaN 说明操作数对于undefined也可以接受var obj = null;console.log(obj++); //0 ???why 为什么null会转换成0？var boolF = false;console.log(boolF++); //0 ???whyvar boolT = true;console.log(boolT++); //1 ???why ##操作符对数据做了什么？？？ 关注类型转换 参考来源： 知乎：JavaScript中运算符优先级的问题？@RednaxelaFX 解释器，树遍历解释器，表达式的求值顺序@RednaxelaFX JavaScript yield*操作符 JavaScript 展开运算符 JavaScript剩余参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何避免JavaScript中的冲突]]></title>
      <url>%2F2017%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DJavaScript%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%2F</url>
      <content type="text"><![CDATA[如何避免JavaScript中的冲突模块化的本质 全局作用域下变量命名冲突描述：在各自模块内都可以使用，一旦整合到一起发生冲突 123456789101112[1]工程师甲编写功能Avar a = 1;var b = 2;alert(a+b);//3 [2]工程师乙添加新功能Bvar a = 2;var b = 1;alert(a-b);//1 解决方案： 立即执行函数表达式封装实现，让变量作用域控制在匿名函数之内。 123456789101112//功能A(function()&#123; var a = 1; var b = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)(); 匿名函数之间存在依赖描述：C功能依赖于A功能的结果 解决方案：在window作用域下定义一个全局变量,把它作为一个桥梁,完成各匿名函数之间的通信 123456789101112131415161718192021//全局变量var str;//功能A(function()&#123; var a = 1; //将b的值赋给str var b = str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将str的值赋给b var b = str; alert(b);//2&#125;)(); 控制全局下变量数量的方法描述：随着匿名函数之间需要通信的变量越多,需要的全局变量也就越多。因此需要严格控制全局变量的数量 12345678910111213141516171819202122232425262728293031//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; //和功能B使用同一个hash键发生冲突 alert(a+b);//3&#125;)();//功能B(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 2; //和功能A使用同一个hash键发生冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; alert(a*2);//4&#125;)(); 解决方案：使用hash对象作为全局变量,可以将需要的变量都作为对象的属性,可以保证全局变量的个数足够少,同时拓展性非常好 123456789101112131415161718192021222324//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)(); hash键名发生冲突描述：A，B，C，D四个模块分配给4个工程师实现4个功能，C依赖于A，并且使用A中的变量a，b，这个时候A中的变量a，b就需要通过挂载到全局对象GLOBAL上的属性实现A，C之间的通信，GLOBAL作为他们的桥梁。 但是新的需求是功能D需要和功能B通信,并使用功能B脚本中的变量a,开发功能D的是工程师丁。由于工程师丁只关心自己的匿名函数和功能B的匿名函数，使用GLOBAL.str却无意中覆盖了功能A中设置的同名变量,导致功能C出错。 解决方案：于是使用命名空间来解决这个问题，在不同的匿名函数下,根据功能声明一个不同的命名空间,然后每个匿名函数中的GLOBAL对象的属性都不要直接挂在GLOBAL对象上,而是挂在此匿名函数的命名空间下 123456789101112131415161718192021222324252627282930313233//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; GLOBAL.A = &#123;&#125;; //将a的值赋给GLOBAL.A.str1 var a = GLOBAL.A.str1 = 1; //将b的值赋给GLOBAL.A.str var b = GLOBAL.A.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; GLOBAL.B = &#123;&#125;; //将a的值赋给GLOBAL.B.str1 var a = GLOBAL.B.str1 = 2; //同名hash引起冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.A.str1的值赋给a var a = GLOBAL.A.str1; //将GLOBAL.A.str的值赋给b var b = GLOBAL.A.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.B.str1的值赋给a var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 如果同一个匿名函数中的程序非常复杂,变量名很多,命名空间还可以进一步拓展,生成二级命名空间 123456789101112//以功能A为例(function()&#123; var a = 1, b = 2; GLOBAL.A = &#123;&#125;; GLOBAL.A.CAT = &#123;&#125;; GLOBAL.A.DOG = &#123;&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; &#125;)(); 代码的冲突问题已经解决了,但可维护性并不强。比如,现在需要让工程师甲去修改功能B。因为工程师甲写的脚本是关于功能A的,他并不知道功能B的脚本情况。为了改善这种局面,需要给代码添加适当的注释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var GLOBAL = &#123;&#125;;GLOBAL.namespace = function(str)&#123; var arr = str.split('.'); var o = GLOBAL; var start = 0; if(arr[0] == 'GLOBAL')&#123; start = 1; &#125;else&#123; start = 0; &#125; for(var i = start; i &lt; arr.length; i++)&#123; o[arr[i]] = o[arr[i]] || &#123;&#125;; o = o[arr[i]]; &#125;&#125;;/** @method 功能A:实现加法运算* @author 工程师甲* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 1; var b = 2; GLOBAL.namespace('A.CAT'); GLOBAL.namespace('A.DOG'); GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.A.str = b; alert(a+b);//3&#125;)();/** @method 功能B:实现减法运算* @author 工程师乙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 2; var b = 1; GLOBAL.namespace('B'); GLOBAL.B.str1 = a; alert(a-b);//1&#125;)();/** @method 功能C:实现乘法运算* @author 工程师丙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.A.str1; var b = GLOBAL.A.str; alert(a*b);//2&#125;)();/** @method 功能D:实现乘2运算* @author 工程师丁* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 让javascript不再冲突,需要 [1]避免全局变量的泛滥 [2]合理使用命名空间 [3]为代码添加必要的注释 本文转载自 如何避免javascript中的冲突 后话 模块化已经非常普及了，但是模块化解决的根本问题还是如何实现JS的私有空间，如何解决代码的依赖关系，如何避免发生冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用markdown遇到的问题]]></title>
      <url>%2F2017%2F05%2F06%2F%E4%BD%BF%E7%94%A8markdown%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[记录一下使用md时遇到的问题 如何把markdown转换成HTML？描述: 网页上的博客都是.html文件，要把.md文件转换成HTML是上传前的第一步 使用github上的开源库，提供了markdown语法转换为HTML https://github.com/chjj/marked markdown转换为HTML的原理其实就是一个通过一个转换器函数marked，接收MarkDown文本作为输入，输出一段HTML。 markdown的内容本质就是一个大字符串，转换器函数使用正则表达式对这些特殊的标识符进行解析，比如 # ## + - &gt; 。比如 对“# ”【#号后紧跟一个空格的，#号前面没内容，#号作为一行文本的开头，注意前面连空格都不能有】解析就会用一个\\标签替换并填充内容，如何判断到哪结束呢？ 解析回车换行符… 注意：对一些特殊字符的解析必须是在开头才有效#表示标题 >表示引用，对于>这种字符的替换要格外注意，这里需要转义，防止XSS。 最后把返回的内容通过操作DOM方式进行文本插值（innerHTML）的方式插入到div容器中.（index.html内） 而node环境下因为没有DOM操作，用模板替换的方式，使用正则把内容替换掉占位符。 markdown插图注意，要在网页上插图，本地的图片是不行的，必须先把本地图片上传到互联网上通过链接的形式插入。 插图时如何自定义图片的宽高？使用md语法进行插图是没办法自定义图片的宽高，但是别忘了，md支持HTML标签的，直接通过img标签的方式设置图片的宽高，md它的本质只是为了让我们抛弃鼠标 在线HTML写MarkDown动态转换为真正的HTML1.把MarkDown放在一个容器盒子里面 2.DOM操作获取盒子内容 3.用转换器函数转为HTML，再插入盒子 遇到的问题等解析到脚本的时候转换才开始，那么页面会显示一段原始的文档，如果把脚本位置放在盒子前面，又获取不到文本内容。 markdown添加样式反正最终md会被转换为html，在html文件中通过link标签引入一段样式即可。 md内部添加一些样式可以使用md支持的font标签，支持color，size，face等样式。 所以，总体的样式可以用外部css设置，简单的添加样式可以使用font标签 离线书写md，批量自动转换为HTML描述： 如果通过每次在html页面中书写md，再转换的话，每次会这样，复制一遍之前的html（因为里面包含了css和转换器脚本），复制自己的md文件内容，覆盖html中的md，然后另存为一个新的html。很费劲… 如何可以根据我们的md文件自动生成对应的html文件呢？？？ 使用Node ，Node是一个JavaScript运行时，提供了我们不依赖浏览器允许脚本的能力，同时它还提供了一些操作文件的API。使用这些API编写脚本可以自动地完成我们的需求。 前置工作： 1.编写一个index.html文件作模板，里面把样式和js加载写好，并设置一个容器盒子，里面放上占位符2.在博客项目的目录下新建一个md文件夹，用来管理存放所有的md文件。 注意：好的习惯可以屏蔽掉一些不必要的操作。 使用文件夹分类管理的思路就是使用软件中的分而治之思想如果把项目目录抽象成一个大object，那么以下的每个文件夹就是子object或者Array。 比如 src目录 就是一个子object,里面可以用css,js,image这些文件夹进行分类管理。而类似于md这种文件夹就像Array，里面就存放了同一类内容，就是我们的博客文件。 利用node 读写目录和文件的API完成自动转换的任务 1.读md目录下的文件 2.读取md文件的内容和模板的内容 3.使用正则对模板和内容进行替换 4.保存（写入文件）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的github]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%88%91%E7%9A%84github%2F</url>
      <content type="text"><![CDATA[前言 每一个开始都是基于痛点的产生 起因 从大学时学JAVA时,就听到老师科普说github就是程序员的微博,在那上面,可以学到很多世界级程序员的代码以及思考问题的方式。但是第一次的github之旅因为英文困扰而快速地点击了右上角。反正又没什么用,有用的话我看中文的博客呗,这算是最早接触把,也因为英文那点事而告终。后来接触github是快毕业的时候,做毕业设计,想找点资源啊,去哪找呢?github上资源多啊,没办法啊,要毕业啊,要做项目,抱着目的的心情,英文这头拦路虎似乎也不是那么可怕了。当时的那个github账号因为第一次算比较”正式”地使用吧,不停地Fock、Star一堆项目,看到介绍不错的先收藏起来,导致最后那个github账号被放弃。这次写下这篇感想也是开始真正准备使用github了 为什么使用github? 每个人遇到的问题不同,让你对一个工具的感触也不同。别人给你说得再多好,也不及你真正遇到痛点的时候,突然出现一样工具,可以瞬间解决你的各种烦恼带来的那种快感。对于我来说,之前也练习过不少代码,一些各种小demo,一些PC页面重构,移动站点的重构,框架的初使用,那会也对代码进行了一些分类管理,但是尽管如此,还是存在很大的问题,比如说每次遇到问题,去网上找了一些解决方案和代码,自己理解以后重写了一份,但是因为太过随意,不知道保存到了哪个角落里-&gt;随意性,而有了github会怎么样呢?github上仓库是可见的啊,你的代码是会展示给别人看的,当然作为喽啰的我是不会有人看的,但是总能下意识地规范自己的行为。其次,每个仓库可以分类管理代码,方便代码的管理,每次写的时候去github上pull,写完代码push。这看似很麻烦,这也是当初我抗拒github的原因,但实际能让我们养成一个良好的习惯,而不是每次到处在硬盘里找。 感悟 简单与复杂,容易与困难。简单=&gt;困难,复杂 === 完善 =&gt; 容易]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript复合类型的隐式转换]]></title>
      <url>%2F2017%2F04%2F09%2FJavaScript%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[为什么很重要在你的编写的代码中,类型转换无处不在。而对于”隐式”转换它就像一个昙花一现般,短暂地出现却又很快地消失。比如:12var arr = [1,2,3];alert(a); 这样类似的代码写的不在少数吧?可是对于alert()这个函数,你知道它接收的参数类型是一个字符串吗?诶不对啊,这里明明传入了一个Array,而且正常显示了,没有报错啊。这就是神秘的隐式转换,悄悄地对你的参数做了转换,最后显示在控制台上。下面来看几段代码123456789101112131415161718var bbb = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bbb);// 10 toString alert(+bbb); // 10 valueOf alert(''+bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == '10'); // true valueOf alert(bbb === '10'); // false 重写两个方法的情况下，如果要输出一个对象，那么会输出什么样的值？如何对对象进行类型转换的？ 从第一个alert()中得到的结果是,输出对象值的时候,实际上调用了对象的toString()方法。 重写两个方法的情况下，加号操作符对对象会产生什么行为？一个加号操作符加一个操作数会发生什么? 加号操作符让对象调用了valueOf()方法。+bb是+ 运算符的一元(unary)形式，(即只有一个操作数)，+运算符显示地将bb转换为数字。 重写两个方法的情况下，字符串，加号操作符对对象产生什么行为？ 字符串，加号操作符让对象调用了valueOf()方法,但是为什么会是valueOf而不是toString()方法呢?这里明明看上去就是字符串拼接啊。 “在有操作符的情况下,valueOf()的优先级比toString()更高” 想要理解这个其实不难,+号操作符和对象在一起时,首先会被认为是一个值运算,所以会调用valueOf()返回一个数值,其次因为加号操作符的两边一边是字符串,一边是数字,对于这种,JavaScript红宝书上是这么说的: 如果只有一个操作数是字符串,则将另一个操作数转换为字符串,然后再将两个字符串拼接起来。 于是数值又悄悄地进行了一次转换String(),看似简单的结果背后实则发生了两次类型转换,类型转换是不是无处不在? 重写两个方法的情况下，把对象显示地转换成字符串会产生什么行为？ 调用对象的toString()方法转换为基本值 重写两个方法的情况下，把对象显示地转换为数字会产生什么行为？ 调用对象的valueOf()方法转换为数值 一个对象如何和一个基本类型进行比较？ 复合类型(对象/数组)先通过valueOf()或者toString()转换为基本类型 根据基本数据类型的比较规则进行类型转换最终比较出结果 JavaScript中的valueOf方法和toSting方法是干什么的？ 把复合类型转换为基本类型 为什么实际中很少调用valueOf()和toString()，但他们还这么重要？ 因为它总在你不知道的时候悄悄地被调用 那么何时调用toString()方法,何时调用valueOf()方法呢?1234567891011121314151617181920212223242526272829一个具有重写的toString()，一个具有重写的valueOf()var aa = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;&#125;alert(aa);// 10 toStringalert(+aa); // 10 toStringalert(''+aa); // 10 toStringalert(String(aa)); // 10 toStringalert(Number(aa)); // 10 toStringalert(aa == '10'); // true toStringvar bb = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bb);// [object Object]alert(+bb); // 10 valueOfalert(''+bb); // 10 valueOfalert(String(bb)); // [object Object]alert(Number(bb)); // 10 valueOfalert(bb == '10'); // true valueOf 9. 只重写toString的情况下，以上问题会发生什么样的行为变化？1234567891011121314输出：调用toString()转换为基本类型值值运算：没调用valueOf()了，而是调用了toString()转换为了数值，即使修改i=“10”,并且打印值的类型，还是数字，而不是字符串。这说明先通过toString()转化为基本数据类型，再通过Number()把字符串转换为数字。分析：1.重写toString方法比原始valueOf方法的优先级，所以复合类型先调用toString()转换为基本类型。2.因为是值运算，所以基本类型string经过Number()二次转换为number。如何验证:aa.i = “10&quot;;alert(+aa); // 10 toStringalert(typeof +aa); // number字符串+对象： 1.调用重写的toString()转换为基本类型 2.数值类型转为字符串类型进行拼接 对象显示转化字符串： 1.调用重写的toString()转换为基本类型Str对象显示转换为数值： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number 相等判断： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number再进行比较-&gt;相等 10. 只重写valueOf的情况下，以上问题会发生什么样的行为变化？1234567输出：1.并没有调用重写的valueOf，而是调用默认的toString()方法，显示[对象 类型]值运算:1.调用重写的valueOf()，转换为基本类型值Number字符串+对象：1.调用重写的valueOf()转换为基本类型值Number 2.转换为str进行拼接 对象显示转化字符串：1.没有调用重写的valueOf()，而是直接调用了默认地toString对象显示转换为数值：1.调用重写的valueOf()转换为基本类型值Number相等判断：1.调用重写的valueOf()转换为基本类型值Number 11. 去掉从Object继承的toString方法的干扰，以上问题会发生什么样的变化？1234567891011121314Object.prototype.toString = null;var cc = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(cc);// 10 valueOfalert(+cc); // 10 valueOfalert(''+cc); // 10 valueOfalert(String(cc)); // 10 valueOfalert(Number(cc)); // 10 valueOfalert(cc == '10'); // true valueOf 因为默认地toString方法没了，所以只能调用重写的valueOf() 总结0.基本上，所有JS数据类型都拥有valueOf和toString这两个方法，null除外。它们俩解决javascript值运算与显示的问题。 还有一个对象没有valueOf()和toString()方法，通过Object.create(null)创建的对象[[Prototype]]属性为null1.toString()用于显示，valueOf()用于值运算。2.默认情况下，根据不同的操作，两个方法的优先级不同。3.在有操作符的情况下，valueOf的优先级比toString高。4.重写会加大它们自动调用的优先级。5.重写toString的情况下，toString()方法会无视valueOf()，1.都会先调用toString()方法转换为基本类型的值，此时如果是”显示”操作就到此为止2.如果是值运算，基本类型的值转化为Number类型进行值运算.6.重写valueOf的情况下，值运算优先调用valueOf，显示地转换为字符串&amp;输出会调用默认地toString()。valueOf()不管返回的是什么基本值，值运算都会对其转换为数值.7.在进行强转字符串的时候将优先调用toString().]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[首先,在了解字符集和字符编码是什么之前先去看看为什么会有字符集和字符编码,它是为了解决什么问题? 字符集的产生我们平时在计算机屏幕上看到的文字内容并不是直接以文字的形式存储在计算机的存储介质中,计算机存储介质中存放的实际上是二进制的比特流。也就是说,不论你在计算机上看到的汉字,英文字母,日文等等,一旦存入计算机存储介质中,最终都是以010101010形式存放。那么如何确保拿出来转换的是汉字不是日文呢?显然,在这两者之间的转换就需要一个统一的规则,不然,当你把文档发给别人,别人的转换规则和你不一样,岂不是就出现乱码了? 所以为了统一转换,字符集就诞生了。简单的说,字符集规定了某个文字对应的二进制数字存放方式(编码)和某串二进制数值代表了哪个文字(解码)的转换关系。 “字符集”就像谍战片中的“译码本”一样,发电报时,大家发送的都是”滴答滴答”的原始信息,但是通过译码本,就可以转换成真实的字符。就像译码本一样,同样的原始信息经过不同的译码本翻译可能得到不同的结果;对于相同的一个字经过不同的译码本转换,翻译出的内容也不一样,这也就是为什么谍战片中大家都这么重视译码本。 对于一个字符集来说要正确编码转码一个字符需要三个关键元素:字库表(character repertoire)、编码字符集(coded character set)、字符编码(character encoding form)。 字库表 是一个相当于所有可读或者可现实字符的数据库,字库表决定了整个字符集能够展示的所有字符的范围。 编码字符集 即用一个编码值code point来表示一个字符在字库中的位置。 字符编码 将编码字符集和实际存储数值之间的转换关系。一般来说都会直接将code point的值作为编码后的值直接存储(ASCII中) 这么看来,字库表和编码字符集看来是必不可少的,既然字库表已经有序号了那为什么不直接把序号作为存储内容呢?干嘛还要多此一举通过字符编码把序号转换成另一种存储格式呢? 因为统一字库表的目的是为了能够涵盖世界上所有的字符,但实际使用的过程中呢,真正用到的字符占字库表的比例是非常低的。比如老美,他们仅仅可能仅仅只用到了ASCII中的128个字符,但是如果都以字库表中的序号来存储的话,原本ASCII中的一个字符只占一个字节,现在一个字符占了三个字节,这显然对他们很不友好。这个时候就出现了UTF-8这样的变成编码。在UTF-8编码中,原本只占一个字节的ASCII字符,仍然只占一个字节。 为什么会有Unicode字符集编码标准?因为ASCII是美国人自己用的,ASCII开始普及之后,各国针对ASCII字符不够自己国家/地区使用,在ASCII上做了扩展,因为此,出现了同一个二进制编码表示不同编码的问题。解决了一个字节不够表示全球中所有符号的问题。 UTF-8和Unicode的关系Unicode就是字符集编码，而UTF-8就是字符编码,就是Unicode规则字库的一种实现形式。unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节)。从unicode到UTF-8并不是直接的对应，而是要过一些算法和规则来转换。UTF-8编码的实现方法，即UTF-8的物理存储和Unicode序号的转换关系。 为什么会出现乱码?编码和解码时使用了不同的字符集。对于字符”很屌”经过UTF-8编码后,它的十六进制表示E5BE88E5B18C这串数字,而我们显示的时候用GBK解码进行展示。(GBK的解码规则是:对于一个字节，如果它是小于127的，那么它就是一个英文单字节。而如果某个字节是大于127，就表示是一个汉字的开始.所以当时会有1个汉字2个英文字符的说法),此时GBK会把这串数字拆成 E5BE 88E5 B18C三组,每组两个字节,所以GBK解码后就成了寰堝睂三个字符。不仅和原来的完全不一样还多了一个。 出现乱码后如何识别原来的想要表达文字? 编码(发现乱码的当前编码,转回二进制) 切割(获取二进制字符串并按字节拆成字节数组) 解码 最后补充一下计算机中存的是二进制,但是常见的用十六进制表示而不用十进制?或者其他八进制?因为二进制过长的数字代码对于阅读带来不便,十进制和二进制没有指数型关系。十六进制简洁且和二进制成倍数关系,两个十六进制就可以表示8个二进制位也就是一个字节。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像程序员般思考]]></title>
      <url>%2F2017%2F04%2F04%2F%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%88%AC%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[平常我们在学习的过程中,比如遇到一个新的术语,新的概念或者所有对于你来说都是未知的”新”东西,你下意识会选择怎么办?我不知道你会怎么办?反正之前的我会先选择维基百科一下看看它是什么(What),然后映入眼前的是大篇幅官方描述,此时如果你有相关领域的经历或者经验(底蕴),很好,轻而易举地理解了它在表述什么,但是如果你之前没有接触过呢?想必看完也是一头雾水。比如socket这个词,你搜词典,它上面的解释”插座,给…配插座”,当然更强大一点的词典,比如有道,它还有网络释义套接字,很好,词典很强大,和维基百科说的也是一样的。 在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 socket是一种操作系统提供的进程间通信机制。[1]socket最初被翻译为把socket译为“媒介(字)”[2]。不久，ARPANET的socket就被翻译为“套接字”，其理由是：[3] 通过这段话,我们得出了几个信息: What:套接字 Do:用于进程间通信 通过这些信息加上我们的”理解”看似已经达到了我们从无到有的认识过程。但这是不属于你的,因为这其实只是凭借着我们大脑的记忆能力强行地进行了一下复制粘贴。这样不牢固的东西是不稳的,就像天龙八部里的慕容复,看似武学渊博,什么都会,名头响亮。但其实他就像一个瓷器,当遇到真正的高手时,就暴露出了问题。因为他无一精通,没有自己的见解,都是照搬别人。但高手之间的对决,往往是变幻莫测的。这就好像我们的程序,完成需求是容易的,难得是维护和迭代。回到socket的问题上,既然是表示网络进程通信为什么不叫Web Communication,这样不更容易理解一下吗?诶,好像这么说也有道理啊,是不是此时感觉之前对socket的理解又动摇了呢?这就是知其然而不知其所以然带来的后果,其实我们真正在看到的一个”新”(可能对于你来说是)的问题时,应该建立这样一个思考问题的过程 为什么会产生这个问题?因为这是人类社会,凡事不会凭空发生,肯定有原因。我觉得了解为什么是拨开神秘面纱的第一步。 其次是How 然后才是What 最后再去建立和别的事物的联系,回头再思考下有什么不足 而对于高明的程序员来说,这其实就是他们的本能的思考和解决问题的行为。 回到socket的产生上,直到我在知乎上看到一篇帖子“Socket为什么要翻译成套接字？”中陈振玥先生的回答才让我反思写下这篇博客记录下——面对于一个未知问题的思考方式。里面大致是这么说的:最早“网络连接”这个词对于那个时代还是一个新兴词汇。当时的网络连接对于大部分人来说是无法理解其含义的,所以作者为了解释清楚,才有了socket,原意想表达的就是建立网络连接就像插插座一样,一方去插,而另一方被插,这就是socket的由来。但是为什么后来变成了套接字呢?这其实更容易理解了,随着发展,大家理解了网络连接的过程,“网络连接”比起早期更复杂了,它被发扬光大了,所以基于这两种情况,插插座这种狭义理解已经不太符合它的定位了。 1. 人类认知的上升 2. 职责的增大 而应试教育和急于求成的心理或多或少地让我们变得浮躁,应试教育让我们的思想变得僵硬,你可以说你在做一道数学题的时候是有在思考问题,但是其实我觉得只能算一半。急于求成的心理往往使我们遇到问题直接询问或者查找如何解决,不加一点地思考,不追根溯源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建静态博客]]></title>
      <url>%2F2017%2F02%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[官方文档：https://hexo.io/github地址：https://github.com/hexojs/hexo主题文档： Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
