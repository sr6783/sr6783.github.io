<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript函数的设计]]></title>
      <url>%2F2017%2F05%2F18%2FJavaScript%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[JavaScript函数设计关键词: 黑匣子 抽象 封装 参数个数检查 参数类型检查 函数的核心理念——抽象和封装过程封装过程：指的是用户只需知道函数名，如何正确的传递参数以及返回值就够了，而内部的逻辑用户无需知道。 抽象：借助抽象，我们才能不关心底层具体的实现/计算过程，而直接在更高层上思考问题。 而函数就是抽象的方式，一个函数就是一个一个完整的行为，函数体内部的语句在执行的时候，函数内部通过条件判断和循环就可以完成非常复杂的逻辑。 函数的执行过程输入（传参）——计算/处理 ——输出（返回结果，如果有） 函数就是一段完整的代码，函数在执行的过程中，如果没有return语句（函数结尾如果没有return语句就是隐含 return undefined）,控制权无法交回被调用的代码。一旦执行到return时，函数就执行完毕，并将结果返回。 ES6中的Generator函数除外，Generator函数的yield类似return，可以返还控制权。 JS中的函数 JavaScript中函数定义参数时没有指定参数的数据类型 JavaScript中的函数不会对参数arguments进行类型检查 JavaScript中的函数不会对arguments进行个数检查 JavaScript中函数没有重载 对比JAVA的函数123public String getRecord(int key) &#123; return db[key]; 修饰符public修饰了函数getRecord的可访问性 String说明了存在返回值并且说明了返回值类型 int key说明了参数类型和参数名字 JAVA函数的定义1、支持重载 2、定义函数时就可以看到函数的访问性（访问控制修饰符） 3、定义函数时就可以看到函数的返回值类型 4、定义函数时就可以看到函数的参数类型 对比Python函数调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt;abs(1, 2)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' Python函数调用1、拥有对参数个数检查的机制 2、拥有对参数类型检查的机制 集百家所长编写健壮的JS函数因为js函数没有对实参进行检查的机制,所以我们编写函数就要自己模拟实现这些机制 从Python中得到的感悟首先，对参数的个数进行检查 利用arguments参数判断实际传入参数的个数,这也就是说即使函数没有定义参数，也可以拿到参数的值，也是很多js库常使用的手段 实现：可选”参数” 123456// 接收2-3个参数，参数b是可选参数，如果只传2个值，b默认为nullfunction abc(a, b, c) &#123; if(arguments.length === 2) &#123; //实际拿到的是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 其次，检查参数的数据类型 使用条件判断的方式判断参数的是否传递，以及参数是否是期望的值 12345678910function log(x, y) &#123; if(typeof y !== 'string') &#123; //检测参数的数据类型 y = 'World'; &#125;&#125; console.log(x, y);log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 从JAVA中得到的感悟JAVA中的函数从函数的定义就可以看到函数的参数类型，是否有返回值和返回值类型 所以为了编写可维护的JavaScript函数，我们可以利用注释和规范的命名实现对函数的描述。 利用函数名描述函数的功能 利用参数名描述参数是什么，利用注释描述参数的数据类型 利用返回值描述结果是什么，利用注释描述返回值的数据类型 或者写一段完整注释包括：描述函数的目的，功能，参数和参数类型，返回值和返回值类型 模拟函数重载函数重载：函数名相同，参数的个数和类型不同，实现不同的功能。 模拟重载：利用条件判断判断参数的个数和参数的类型，来实现重载。 参考： 廖雪峰·Python教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包中使用this存在的问题]]></title>
      <url>%2F2017%2F05%2F16%2F%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8this%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[闭包中使用this存在的问题关键词: 闭包 函数声明时 函数运行时 词法作用域 特殊变量 箭头函数 前言也是为什么老是有var that = this;的写法以及箭头函数产生的原因。 闭包中使用this的问题在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。 12345678910111213//在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。// 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; return function() &#123; //闭包 return this.name; //在闭包中使用this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 Window 为什么this会指向undefined呢？这是因为每个函数在调用的时候都会自动取得两个特殊的变量，this和arguments，内部函数在搜索这2个变量的时候，只会搜索到其活动对象为止，因此永远不可能访问到外部函数中的这2个变量。 那么如何访问到这两个变量呢？把外部作用域中的this保存到一个闭包能访问到的变量里，并在闭包中引用那个变量，而不是引用this常见的 12var this = that;var args = Array.prototype.slice.call(arguments); 上例的修改后： 12345678910111213var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; var that = this; //修改：保存外部作用域的this到一个闭包能访问到变量中 return function() &#123; //闭包 //return this.name; //在闭包中使用this return that.name; //修改：在闭包中通过引用that来引用外部作用域的特殊变量this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 this指向Window ES6的箭头函数：ES6的箭头函数最佳的使用姿势就是解决this指向问题。因为在JavaScript中，对象之间的调用是非常繁杂的，一不小心遇到this被篡改的问题，导致后面的代码出错： 比如 1234567891011121314class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(function() &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); //undefined says hi 这是一个比较经典的this被篡改的问题，因为这个setTimeout函数，他的this指向window对象。 我们可以利用一个变量保存住这个this指针，也或者使用bind(this)方法，但有了箭头函数，等于函数本身集成了保存this指针的功能，这让我们不是处处提防this陷阱。同样的，基于这个原因，箭头函数中没有自己的this，但当你在箭头函数内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的 this。 箭头函数最常用于回调函数，如事件处理器或定时器中12345678910111213141516171819202122232425262728class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(() =&gt; &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); // animal says hi//等价于class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; var that = this; setTimeout(function() &#123; console.log(that.type + ’says’ + say); &#125;, 1000); &#125;&#125; 对箭头函数的误解 最大的误解：箭头函数使用的是外部函数（这里理解成父函数）的this 是否局部（Lexical）？12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;,100);&#125;foo.call( &#123; id: 42 &#125; );// id: 42 这里的 =&gt; 箭头函数看起来把它内部的this绑定为父函数 foo() 里的 this。如果这个内部函数是一个常规的函数（声明或表达式），它的 this将类似 setTimeout如何调用函数一样被控制着。 但是实际上是箭头函数内部根本没有this变量，对于this变量的访问变量就像根据词法作用域查找一般变量一样,查找到有this变量的外层作用域，而不是父级作用域。 箭头函数的注意1）箭头函数 =&gt; 所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去”, 虽然 =&gt; 箭头函数没有一个自己的 this，但当你在内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的this。 123456789101112function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;; &#125;; &#125;;&#125;foo.call( &#123; id: 42 &#125; )()()();// id: 42 有多少次 this 的绑定执行了呢？大部分人会认为有4次——每个函数里各一次。 事实上更准确地说，只有一次才对，它发生于 foo() 函数中。 这些接连内嵌的函数们都没有声明它们自己的 this，所以 this.id 的引用会简单地顺着作用域链查找，一直查到 foo() 函数，它是第一处能找到一个确切存在的 this 的地方。 说白了跟其它局部变量的常规处理是一致的！ 换句话说，正如同 Dave 说的一样，this 生来局部，而且一直都保持局部态。=&gt;箭头函数并不会绑定一个 this 变量，它的作用域会如同寻常所做的一样一层层地去往上查找。 2)不仅仅是this 如果你贸贸然地同意了“箭头函数就是常规function的语法糖”这样的观点，那是不正确的，因为事实并非如此——箭头函数里并不按常规支持 var self = this 或者 .bind(this) 这样的糖果。 那些错误的解释都是典型的“给对了答案却讲错了原因”，就像你在高中代数课的测试上明明写对了答案，但老师仍会画圈圈告诉你用错方法了——如何解得答案才是最重要的！ 另外，关于“=&gt;箭头函数不绑定自身的 this，而允许局部作用域的方案来沿袭处理之”的正确描述，也解释了箭头函数的另一个情况——它们在函数内部不走寻常路的孩子不仅仅是 this。 事实上 =&gt;箭头函数并不绑定 this，arguments，super(ES6)，抑或 new.target(ES6)。 这是真的，对于上述的四个（未来可能有更多）地方，箭头函数不会绑定那些局部变量，所有涉及它们的引用，都会沿袭向上查找外层作用域链的方案来处理。 12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log("args:", arguments); &#125;,100);&#125;foo( 2, 4, 6, 8 );// args: [2, 4, 6, 8] 这段代码中，=&gt;箭头函数并没有绑定 arguments，所以它会以 foo() 的 arguments 来取而代之，而 super 和 new.target 也是一样的情况。 3）this在箭头函数中被绑定，4种绑定规则中的无论哪种都无法改变其绑定 4）箭头函数不可以当作构造函数，也就是不可以使用new命令，否则会报错 最后虽然箭头函数可以把作用域和this机制联系起来，但是却容易混淆，使代码难以维护。应该在作用域和this机制中二选一，否则就会造成混淆。要么只使用词法作用域，要么只使用this机制，必要时使用bind()。尽量避免使用that=this和箭头函数共同使用。 参考： ES6 箭头函数中的 this？你可能想多了（翻译） ECMAScript 6 入门-箭头函数 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解JavaScript中对象内容的访问方式]]></title>
      <url>%2F2017%2F05%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[整理一下对象访问两种方式的区别以及持续更新不同的使用场景 对象内容的访问的两种方式： . 操作符：通常称为“属性访问” [ ] 操作符：通常称为“键访问” 属性访问和键访问的异同相同实际上它们访问的是同一个位置，并且会返回相同的值 区别 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。 . 操作符后面总是字符串，所以为对象增加属性的时候使用点语法，会自动把属性名称转为字符串， 举例： 1.如果要引用名称为 “Super- Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效 的标识符属性名。 2.使用Symbol值作为对象的属性名时只能使用 [ ] 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 123456789101112131415161718var mySymbol = Symbol();//第一种写法var o = &#123;&#125;;o.mySymbol = 'Hello';//第二种写法var o = &#123;&#125;;o[mySymbol] = 'Hello';//第三种写法var o = &#123; [mySymbol]: 'Hello!'&#125;;// 第四种写法var o = &#123;&#125;;Object.defineProperty(o, mySymbol, &#123; value: 'Hello!' &#125;); 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意：第一种写法是不会读取mySymbol作为标识符所指代的那个值的，因为点语法后面总是字符串，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 123o.mySymbol = 'Hello!';o[mySymbol] // undefinedo['mySymbol'] // "Hello!" 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 [ ] 使用场景1.可计算属性名 2.Symbol值作属性名 3.需要使用变量方式遍历属性 4.函数传参，参数作属性名，或者属性名的一部分，只能使用 [ ] 5.使用对象法进行数组去重，对象的键是一个变量 参考：ECMAScript6 入门——Symbol]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运算符]]></title>
      <url>%2F2017%2F05%2F10%2FJavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[相关关键词 表达式 优先级 结合性 执行顺序 求值顺序 JavaScript运算符 也叫操作符，英文：operator，关于运算符，除了都知道的优先级，还要知道Associativity JavaScript中的运算符大多由标点符号表示，少数由关键字表示，每一个运算符具有不同的行为，运算符始终都遵循着一些固定语法。一些运算符可以作用于任何数据类型， 但仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回一个特定类型的值，在下面的运算符规则表中，箭头前为运算符操作数的类型，箭头后为运算结果的类型 分类 JavaScript的运算符总共有59个，如果根据其操作数的个数进行分类，分为一元运算符，二元运算符，三元运算符。而它们的目的都是一致的: 将一个到多个表达式合并为一个表达式 优先级和结合性 运算符优先级控制着运算符的执行顺序，优先级高的运算符的执行总是先于优先级运算符低的运算符——————错误的理解 修正：不同操作相邻出现的时候，表达式是作为左操作符的后操作数呢？还是作为右操作符的前操作数呢？=&gt;这就是操作符优先级干的事 对优先级错误的理解： 认为拿到一行语句，先按照操作符的优先级划分，找到最高优先级的操作符，先求值。 所以就对 baz&amp;&amp; fn()这样的代码存在困惑，因为如果这么理解的话，fn()的优先级最高，那么无论如何都会先执行 fn()再去 &amp;&amp; 判断，可实际的是 &amp;&amp;判断前面的baz是否存在而决定是否执行后面的fn()，此时发生冲突。但实际上所谓的优先级是指操作数结合操作符，优先结合。即同一个操作数被左右两个操作符共同使用的时候，此时这个操作数并不会被两个操作符共同使用，而决定它被谁使用的依据就是操作符的优先级。不是说谁的优先级高就先给谁求值。 简单一点的说，所谓的优先级就是加个括号,而优先级和结合性就是决定括号怎么加 那么何时求值？比如 d = a + (b+c) 对表达式d求值，首先对表达式a求值，返回；然后要对 + 后的一个表达式求值，此时 + 后面的表达式结果依赖于b + c，此时b + c才开始求值，因为最终的结果依赖b + c 的结果，所以才有了求值。 所以像短路运算符 &amp;&amp; 和 || 一起出现的时候，因为&amp;&amp;的优先级要比||高，所以&amp;&amp;优先结合操作数（但是并不意味着要立即求值，还是要根据从左往右的顺序，先对第一个操作数求值。剩下的，有依赖有需求才会求值。） 所以千万不要再理解成优先级高，优先求值 优先级是怎么产生的？1234567891011121314例1：var a =42, b;b = (a++, a);a; //43b; //43如果去掉括号会怎么样？var a=42, b;b = a++, a;a; //43b; //42 【1】注意： b的结果不一样了，上面代码发生了什么？说明了什么？ 原因就在于,运算符的优先级比=低,当不同操作相邻（, =）出现时，表达式a++是作为=的后操作数呢？还是作为,的前操作数呢？ =&gt;操作符的优先级工作了 =&gt;因为=&gt;的优先级高于, =&gt;原式&lt;=&gt;(b = a++), a; =&gt;此时a++后自增，先返回值，所以表达式b的值是42 1234简单的例2：fn01() || fn02 &amp;&amp; fn03();//等价于fn01() || (fn02 &amp;&amp; fn03()); // &amp;&amp; 优先级高于 || fn02结合&amp;&amp; 1234567891011121314151617181920212223242526例3：var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;分析：1.先解决优先级问题=&gt;哪里发生了优先级问题？ a b c c b c b a (看操作数两边的符号，除了第一个操作数和最后一个操作数以及三元表达式 ? a :都会发生优先级问题)2.再来一遍，a发生优先级问题，看表达式a的左边和右边，&amp;&amp; 高于 = =&gt; a 作为&amp;&amp;的前操作数3.再看表达式b，b发生优先级问题，看表达式b的左边和右边,&amp;&amp; 高于 ||=&gt; b 作为&amp;&amp;的后操作数=&gt;var d = (a &amp;&amp; b) || c ? c || b ? a : c &amp;&amp; b : a;//...重复以上步骤，得出以下结果=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;做到这一步无法往下做了，可以看成e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;此时仅有优先级已经无法满足求值的需求了。--------------- ---------------- Associativity（结合性） 如果所有操作符优先级一样，结合性决定了执行结果的唯一性。 结合性是怎么起作用的？当表达式相邻的操作符具有相同的优先级时，优先级已经不能决定表达式最终结果的时候，结合性就起作用了。 12345678910111213141516171819202122回到之前例子没有解决的问题：=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;这里没有可能性二//可能一e ? (f ? a : g) : a; true --- a / true --- (f ? a : g) / \false --- ge \ false --- a 结合性解决了什么问题？ 当优先级一样的时候括号怎么加 1a OP b OP c 左结合性（从左到右）意味着它被处理为(a OP b) OP c，而右结合性（从右到左）意味着它被解释为a OP (b OP c)。而对于以下代码右结合性是正确的，所以你可以写： 1234567891011a = b = 5;分析：对于表达式b，左边和右边是相同的操作符，优先级一样的。所以优先级已经无法解决这种情况下的执行结果了。显然，如果只有优先级的话，a = b = 5; //可能性1(a = b) = 5;//可能性2a = (b = 5);但是由于(a = b) = 5中，(a = b)的结果并不是一个变量，而是一个返回表达式a赋值后的结果2，因此它不能出现在等号的左边！所以以上最终的执行结果只有可能是可能性2 那么： 12345678910111213141516171819202122232425262728293031323334a?b:c?d:e//可能性一(a?b:c)?d:e true --- d / true --- b / \ a false --- e true --- d / \false --- c \ false ---e =&gt; a 执行结果 d || e //可能性二（因为三元表达式右结合）a?b:(c?d:e) true --- b / a true --- d \ / false --- (c?d:e) \ false ---e =&gt; a 执行结果 b || d || e 结果不唯一了，所以结合性干的事就是确保结果的唯一性。 这个要怎么算？先看优先级，两个一样。再看结合性，右结合，所以：先算c?d:e再算 a?b:（c?d:e） 这就是所谓右结合。如果是左结合的话 就是先算a?b:c再算 （a?b:c）?d:e实际上，一般结合性的问题都可以用括号来解决。 先要考虑优先级，有相同优先级的就看结合性以决定括号的添加方式。结合性决定处理相同优先级的运算符的顺序 或者说为什么结合性不同影响着执行结果？？？ 因为表达式可能会产生副作用，比如函数调用: 1var a = foo() &amp;&amp; bar(); 这里foo()会首先执行，它的返回结果决定了bar()是否执行。所以如果bar(）在foo（）之前执行，整个结果完全不同。 如何更好理解操作符的结合性？？？ 想象一下，什么情况下 AB 不等于 BA 矩阵（不考虑单位矩阵的情况下） 执行顺序 执行顺序是不变的，总是从左到右。优先级和结合性并没有影响代码的执行顺序，也无法影响，它们做的是改变了表达式的求值顺序，注意 执行顺序 != 求值顺序 1234567891011121314151617181920var a=1;b=(a=3)+a++;这个例子中运算顺序是这样的1.计算b2.a＝33.a++(设为c)4.计算a（这时候a变成了4已经，不是再最后才变得，但表达式使用的是a++的结果c，也就是a原来的值）5.计算3+c6.把3+c赋值给b = / \ b + / \ = ++ / \ / a 3 a 深入浅出优先级，结合性，执行顺序，求值顺序 代码执行顺序是永远不变的，从左往右执行。 而优先级和结合性是如何添加括号的依据，表达式越先求值的说明离AST根节点越远，为什么？先求值的说明依赖少，有依赖的还得继续向下遍历。 什么是左值(Left-hand-side expressions) Left values are the destination of an assignment. 左值指的是赋值操作的目标，也就是能出现在赋值表达式左边的表达式，自定义的函数不能返回左值是ECMAScript的规范。 那么什么类型的值可以出现在赋值表达式的左侧呢？变量对象属性数组元素 运算符总结（持续更新） 运算符总结 优先级 运算符 操作 结合性 类型 20 ( … ) 分组 N/A N/A 19 … . … 成员访问 l-to-r 19 … [ … ] 成员访问 l-to-r N/A 19 new … ( … ) 有参构造 N/A N/A 18 … ( … ) 函数调用 l-to-r N/A 18 new … new.target操作符检测是否用new操作符调用函数/构造函数 r-to-l new.target=&gt;undefined/ 在类构造函数中，new.target指的是直接调用的构造函数new。 17 … ++ 后自增 N/A N/A 17 … – 后自减 N/A N/A 16 ! … 逻辑非 r-to-l bool-&gt;bool 16 ~ … 按位求反 r-to-l 16 + … 一元加(注意区别于二元加) r-to-l any=&gt;num 16 - … 一元减(注意区别于二元减) r-to-l any=&gt;num 16 ++ … 先自增 r-to-l 属于算术运算符，操作lval 16 – … 先自减 r-to-l 属于算术运算符，操作lval 16 typeof … 判断类型 r-to-l any=&gt;str 16 void … 返回空 r-to-l any=&gt;undefined 16 delete … 删除属性 r-to-l lval-&gt;bool 15 … … 幂运算 r-to-l any,any=&gt;num，求幂前会发生类型转换num 14 … * … 求积 l-to-r any,any=&gt;num，求积前会发生类型转换num 14 … / … 求商 l-to-r any,any=&gt;num，求商前会发生类型转换num 14 … % … 取余 l-to-r any,any=&gt;num，求商前会发生类型转换num 13 … + … 求和/拼接(考虑类型转换) l-to-r any,any=&gt;any 13 … - … 求差(考虑隐式转换） l-to-r any,any=&gt;num 12 … &lt;&lt; … 按位左移 l-to-r 12 … &gt;&gt; … 按位右移 l-to-r 12 … &gt;&gt;&gt; … 无符号右移 l-to-r 11 … &lt; … 小于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &lt;= … 小于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt; … 大于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt;= … 大于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … in … 测试属性 l-to-r str,obj=&gt;bool 11 … instanceof … 测试对象类(含原型链) l-to-r obj,fn=&gt;bool 10 … == … 测试相等 l-to-r any,any=&gt;bool 10 … != … 测试不等 l-to-r any,any=&gt;bool 10 … === … 测试严等 l-to-r any,any=&gt;bool 10 … !== … 测试严不等 l-to-r any,any=&gt;bool 9 … &amp; … 按位与 l-to-r 8 … ^ … 按位非 l-to-r 7 … | … 按位或 l-to-r 6 … &amp;&amp; … 逻辑与（操作数选择器） l-to-r any,any=&gt;any 5 … || … 逻辑或（操作数选择器） l-to-r any,any=&gt;any 4 … ? … : … 三元表达式 r-to-l bool,any,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … += … 运算且赋值 r-to-l lval,any=&gt;any 3 … -= … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … /= … 运算且赋值 r-to-l lval,any=&gt;any 3 … %= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &lt;&lt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &amp;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … ^= … 运算且赋值 r-to-l lval,any=&gt;any 3 … |= … 运算且赋值 r-to-l lval,any=&gt;any 2 yield … 暂停当前gen函数执行，返回表达式的值给gen函数的调用者 r-to-l any=&gt;any 2 yield … 用于在一个gen函数中调用另一个gen函数 r-to-l AnoFn*()=&gt;any 1 … … 展开运算符 r-to-l array=&gt;any 0 , … 忽略第一个操作数，返回第二个操作数 r-to-l any,any=&gt;any 注： l-to-r : left-to-right 左结合 r-to-l : right-to-left 右结合 lval : leftValue 左值 in右侧必须是一个对象。例如，您可以指定使用String构造函数创建的字符串，但不能指定字符串文字。in操作符会检测原型链上的属性。使用delete操作符删除属性，则操作in员返回false该属性。如果将属性设置为undefined但不将其删除，则in该属性的操作符返回true。 instanceof操作符会检测原型链。 关于–,++操作符报错“ReferenceError: Invalid left-hand side expression in postfix operation” ，这里报的是引用错误，其实想想应该可以这么理解因为++ 和 –操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪返？-&gt;肯定需要一个容器，这个容器就是左值. 123456789101112131415161718192021222324252627// ++ --操作符对操作数有要求吗？是不是只能操作左值?//Invalid left-hand side expression in postfix operationvar str = 'abc';console.log(str++); // NaN 说明可以操作字符串//console.log(5++);//ReferenceError: Invalid left-hand side expression in postfix operation 说明不能直接操作值//引用错误：出现这个的原因是因为++ 和 --操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪放？-&gt;需要一个容器 （因为值是不可变的)var o = &#123;&#125;;console.log(o++); // NaN 说明可以操作对象var b;console.log(b++); //NaN 说明操作数对于undefined也可以接受var obj = null;console.log(obj++); //0 ???why 为什么null会转换成0？var boolF = false;console.log(boolF++); //0 ???whyvar boolT = true;console.log(boolT++); //1 ???why ##操作符对数据做了什么？？？ 关注类型转换 参考来源： 知乎：JavaScript中运算符优先级的问题？@RednaxelaFX 解释器，树遍历解释器，表达式的求值顺序@RednaxelaFX JavaScript yield*操作符 JavaScript 展开运算符 JavaScript剩余参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何避免JavaScript中的冲突]]></title>
      <url>%2F2017%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DJavaScript%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%2F</url>
      <content type="text"><![CDATA[如何避免JavaScript中的冲突模块化的本质 全局作用域下变量命名冲突描述：在各自模块内都可以使用，一旦整合到一起发生冲突 123456789101112[1]工程师甲编写功能Avar a = 1;var b = 2;alert(a+b);//3 [2]工程师乙添加新功能Bvar a = 2;var b = 1;alert(a-b);//1 解决方案： 立即执行函数表达式封装实现，让变量作用域控制在匿名函数之内。 123456789101112//功能A(function()&#123; var a = 1; var b = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)(); 匿名函数之间存在依赖描述：C功能依赖于A功能的结果 解决方案：在window作用域下定义一个全局变量,把它作为一个桥梁,完成各匿名函数之间的通信 123456789101112131415161718192021//全局变量var str;//功能A(function()&#123; var a = 1; //将b的值赋给str var b = str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将str的值赋给b var b = str; alert(b);//2&#125;)(); 控制全局下变量数量的方法描述：随着匿名函数之间需要通信的变量越多,需要的全局变量也就越多。因此需要严格控制全局变量的数量 12345678910111213141516171819202122232425262728293031//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; //和功能B使用同一个hash键发生冲突 alert(a+b);//3&#125;)();//功能B(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 2; //和功能A使用同一个hash键发生冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; alert(a*2);//4&#125;)(); 解决方案：使用hash对象作为全局变量,可以将需要的变量都作为对象的属性,可以保证全局变量的个数足够少,同时拓展性非常好 123456789101112131415161718192021222324//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)(); hash键名发生冲突描述：A，B，C，D四个模块分配给4个工程师实现4个功能，C依赖于A，并且使用A中的变量a，b，这个时候A中的变量a，b就需要通过挂载到全局对象GLOBAL上的属性实现A，C之间的通信，GLOBAL作为他们的桥梁。 但是新的需求是功能D需要和功能B通信,并使用功能B脚本中的变量a,开发功能D的是工程师丁。由于工程师丁只关心自己的匿名函数和功能B的匿名函数，使用GLOBAL.str却无意中覆盖了功能A中设置的同名变量,导致功能C出错。 解决方案：于是使用命名空间来解决这个问题，在不同的匿名函数下,根据功能声明一个不同的命名空间,然后每个匿名函数中的GLOBAL对象的属性都不要直接挂在GLOBAL对象上,而是挂在此匿名函数的命名空间下 123456789101112131415161718192021222324252627282930313233//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; GLOBAL.A = &#123;&#125;; //将a的值赋给GLOBAL.A.str1 var a = GLOBAL.A.str1 = 1; //将b的值赋给GLOBAL.A.str var b = GLOBAL.A.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; GLOBAL.B = &#123;&#125;; //将a的值赋给GLOBAL.B.str1 var a = GLOBAL.B.str1 = 2; //同名hash引起冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.A.str1的值赋给a var a = GLOBAL.A.str1; //将GLOBAL.A.str的值赋给b var b = GLOBAL.A.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.B.str1的值赋给a var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 如果同一个匿名函数中的程序非常复杂,变量名很多,命名空间还可以进一步拓展,生成二级命名空间 123456789101112//以功能A为例(function()&#123; var a = 1, b = 2; GLOBAL.A = &#123;&#125;; GLOBAL.A.CAT = &#123;&#125;; GLOBAL.A.DOG = &#123;&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; &#125;)(); 代码的冲突问题已经解决了,但可维护性并不强。比如,现在需要让工程师甲去修改功能B。因为工程师甲写的脚本是关于功能A的,他并不知道功能B的脚本情况。为了改善这种局面,需要给代码添加适当的注释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var GLOBAL = &#123;&#125;;GLOBAL.namespace = function(str)&#123; var arr = str.split('.'); var o = GLOBAL; var start = 0; if(arr[0] == 'GLOBAL')&#123; start = 1; &#125;else&#123; start = 0; &#125; for(var i = start; i &lt; arr.length; i++)&#123; o[arr[i]] = o[arr[i]] || &#123;&#125;; o = o[arr[i]]; &#125;&#125;;/** @method 功能A:实现加法运算* @author 工程师甲* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 1; var b = 2; GLOBAL.namespace('A.CAT'); GLOBAL.namespace('A.DOG'); GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.A.str = b; alert(a+b);//3&#125;)();/** @method 功能B:实现减法运算* @author 工程师乙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 2; var b = 1; GLOBAL.namespace('B'); GLOBAL.B.str1 = a; alert(a-b);//1&#125;)();/** @method 功能C:实现乘法运算* @author 工程师丙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.A.str1; var b = GLOBAL.A.str; alert(a*b);//2&#125;)();/** @method 功能D:实现乘2运算* @author 工程师丁* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 让javascript不再冲突,需要 [1]避免全局变量的泛滥 [2]合理使用命名空间 [3]为代码添加必要的注释 本文转载自 如何避免javascript中的冲突 后话 模块化已经非常普及了，但是模块化解决的根本问题还是如何实现JS的私有空间，如何解决代码的依赖关系，如何避免发生冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用markdown遇到的问题]]></title>
      <url>%2F2017%2F05%2F06%2F%E4%BD%BF%E7%94%A8markdown%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[记录一下使用md时遇到的问题 如何把markdown转换成HTML？描述: 网页上的博客都是.html文件，要把.md文件转换成HTML是上传前的第一步 使用github上的开源库，提供了markdown语法转换为HTML https://github.com/chjj/marked markdown转换为HTML的原理其实就是一个通过一个转换器函数marked，接收MarkDown文本作为输入，输出一段HTML。 markdown的内容本质就是一个大字符串，转换器函数使用正则表达式对这些特殊的标识符进行解析，比如 # ## + - &gt; 。比如 对“# ”【#号后紧跟一个空格的，#号前面没内容，#号作为一行文本的开头，注意前面连空格都不能有】解析就会用一个\\标签替换并填充内容，如何判断到哪结束呢？ 解析回车换行符… 注意：对一些特殊字符的解析必须是在开头才有效#表示标题 >表示引用，对于>这种字符的替换要格外注意，这里需要转义，防止XSS。 最后把返回的内容通过操作DOM方式进行文本插值（innerHTML）的方式插入到div容器中.（index.html内） 而node环境下因为没有DOM操作，用模板替换的方式，使用正则把内容替换掉占位符。 markdown插图注意，要在网页上插图，本地的图片是不行的，必须先把本地图片上传到互联网上通过链接的形式插入。 插图时如何自定义图片的宽高？使用md语法进行插图是没办法自定义图片的宽高，但是别忘了，md支持HTML标签的，直接通过img标签的方式设置图片的宽高，md它的本质只是为了让我们抛弃鼠标 在线HTML写MarkDown动态转换为真正的HTML1.把MarkDown放在一个容器盒子里面 2.DOM操作获取盒子内容 3.用转换器函数转为HTML，再插入盒子 遇到的问题等解析到脚本的时候转换才开始，那么页面会显示一段原始的文档，如果把脚本位置放在盒子前面，又获取不到文本内容。 markdown添加样式反正最终md会被转换为html，在html文件中通过link标签引入一段样式即可。 md内部添加一些样式可以使用md支持的font标签，支持color，size，face等样式。 所以，总体的样式可以用外部css设置，简单的添加样式可以使用font标签 离线书写md，批量自动转换为HTML描述： 如果通过每次在html页面中书写md，再转换的话，每次会这样，复制一遍之前的html（因为里面包含了css和转换器脚本），复制自己的md文件内容，覆盖html中的md，然后另存为一个新的html。很费劲… 如何可以根据我们的md文件自动生成对应的html文件呢？？？ 使用Node ，Node是一个JavaScript运行时，提供了我们不依赖浏览器允许脚本的能力，同时它还提供了一些操作文件的API。使用这些API编写脚本可以自动地完成我们的需求。 前置工作： 1.编写一个index.html文件作模板，里面把样式和js加载写好，并设置一个容器盒子，里面放上占位符2.在博客项目的目录下新建一个md文件夹，用来管理存放所有的md文件。 注意：好的习惯可以屏蔽掉一些不必要的操作。 使用文件夹分类管理的思路就是使用软件中的分而治之思想如果把项目目录抽象成一个大object，那么以下的每个文件夹就是子object或者Array。 比如 src目录 就是一个子object,里面可以用css,js,image这些文件夹进行分类管理。而类似于md这种文件夹就像Array，里面就存放了同一类内容，就是我们的博客文件。 利用node 读写目录和文件的API完成自动转换的任务 1.读md目录下的文件 2.读取md文件的内容和模板的内容 3.使用正则对模板和内容进行替换 4.保存（写入文件）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的github]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%88%91%E7%9A%84github%2F</url>
      <content type="text"><![CDATA[前言 每一个开始都是基于痛点的产生 起因 从大学时学JAVA时,就听到老师科普说github就是程序员的微博,在那上面,可以学到很多世界级程序员的代码以及思考问题的方式。但是第一次的github之旅因为英文困扰而快速地点击了右上角。反正又没什么用,有用的话我看中文的博客呗,这算是最早接触把,也因为英文那点事而告终。后来接触github是快毕业的时候,做毕业设计,想找点资源啊,去哪找呢?github上资源多啊,没办法啊,要毕业啊,要做项目,抱着目的的心情,英文这头拦路虎似乎也不是那么可怕了。当时的那个github账号因为第一次算比较”正式”地使用吧,不停地Fock、Star一堆项目,看到介绍不错的先收藏起来,导致最后那个github账号被放弃。这次写下这篇感想也是开始真正准备使用github了 为什么使用github? 每个人遇到的问题不同,让你对一个工具的感触也不同。别人给你说得再多好,也不及你真正遇到痛点的时候,突然出现一样工具,可以瞬间解决你的各种烦恼带来的那种快感。对于我来说,之前也练习过不少代码,一些各种小demo,一些PC页面重构,移动站点的重构,框架的初使用,那会也对代码进行了一些分类管理,但是尽管如此,还是存在很大的问题,比如说每次遇到问题,去网上找了一些解决方案和代码,自己理解以后重写了一份,但是因为太过随意,不知道保存到了哪个角落里-&gt;随意性,而有了github会怎么样呢?github上仓库是可见的啊,你的代码是会展示给别人看的,当然作为喽啰的我是不会有人看的,但是总能下意识地规范自己的行为。其次,每个仓库可以分类管理代码,方便代码的管理,每次写的时候去github上pull,写完代码push。这看似很麻烦,这也是当初我抗拒github的原因,但实际能让我们养成一个良好的习惯,而不是每次到处在硬盘里找。 感悟 简单与复杂,容易与困难。简单=&gt;困难,复杂 === 完善 =&gt; 容易]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript复合类型的隐式转换]]></title>
      <url>%2F2017%2F04%2F09%2FJavaScript%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[为什么很重要在你的编写的代码中,类型转换无处不在。而对于”隐式”转换它就像一个昙花一现般,短暂地出现却又很快地消失。比如:12var arr = [1,2,3];alert(a); 这样类似的代码写的不在少数吧?可是对于alert()这个函数,你知道它接收的参数类型是一个字符串吗?诶不对啊,这里明明传入了一个Array,而且正常显示了,没有报错啊。这就是神秘的隐式转换,悄悄地对你的参数做了转换,最后显示在控制台上。下面来看几段代码123456789101112131415161718var bbb = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bbb);// 10 toString alert(+bbb); // 10 valueOf alert(''+bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == '10'); // true valueOf alert(bbb === '10'); // false 重写两个方法的情况下，如果要输出一个对象，那么会输出什么样的值？如何对对象进行类型转换的？ 从第一个alert()中得到的结果是,输出对象值的时候,实际上调用了对象的toString()方法。 重写两个方法的情况下，加号操作符对对象会产生什么行为？一个加号操作符加一个操作数会发生什么? 加号操作符让对象调用了valueOf()方法。+bb是+ 运算符的一元(unary)形式，(即只有一个操作数)，+运算符显示地将bb转换为数字。 重写两个方法的情况下，字符串，加号操作符对对象产生什么行为？ 字符串，加号操作符让对象调用了valueOf()方法,但是为什么会是valueOf而不是toString()方法呢?这里明明看上去就是字符串拼接啊。 “在有操作符的情况下,valueOf()的优先级比toString()更高” 想要理解这个其实不难,+号操作符和对象在一起时,首先会被认为是一个值运算,所以会调用valueOf()返回一个数值,其次因为加号操作符的两边一边是字符串,一边是数字,对于这种,JavaScript红宝书上是这么说的: 如果只有一个操作数是字符串,则将另一个操作数转换为字符串,然后再将两个字符串拼接起来。 于是数值又悄悄地进行了一次转换String(),看似简单的结果背后实则发生了两次类型转换,类型转换是不是无处不在? 重写两个方法的情况下，把对象显示地转换成字符串会产生什么行为？ 调用对象的toString()方法转换为基本值 重写两个方法的情况下，把对象显示地转换为数字会产生什么行为？ 调用对象的valueOf()方法转换为数值 一个对象如何和一个基本类型进行比较？ 复合类型(对象/数组)先通过valueOf()或者toString()转换为基本类型 根据基本数据类型的比较规则进行类型转换最终比较出结果 JavaScript中的valueOf方法和toSting方法是干什么的？ 把复合类型转换为基本类型 为什么实际中很少调用valueOf()和toString()，但他们还这么重要？ 因为它总在你不知道的时候悄悄地被调用 那么何时调用toString()方法,何时调用valueOf()方法呢?1234567891011121314151617181920212223242526272829一个具有重写的toString()，一个具有重写的valueOf()var aa = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;&#125;alert(aa);// 10 toStringalert(+aa); // 10 toStringalert(''+aa); // 10 toStringalert(String(aa)); // 10 toStringalert(Number(aa)); // 10 toStringalert(aa == '10'); // true toStringvar bb = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bb);// [object Object]alert(+bb); // 10 valueOfalert(''+bb); // 10 valueOfalert(String(bb)); // [object Object]alert(Number(bb)); // 10 valueOfalert(bb == '10'); // true valueOf 9. 只重写toString的情况下，以上问题会发生什么样的行为变化？1234567891011121314输出：调用toString()转换为基本类型值值运算：没调用valueOf()了，而是调用了toString()转换为了数值，即使修改i=“10”,并且打印值的类型，还是数字，而不是字符串。这说明先通过toString()转化为基本数据类型，再通过Number()把字符串转换为数字。分析：1.重写toString方法比原始valueOf方法的优先级，所以复合类型先调用toString()转换为基本类型。2.因为是值运算，所以基本类型string经过Number()二次转换为number。如何验证:aa.i = “10&quot;;alert(+aa); // 10 toStringalert(typeof +aa); // number字符串+对象： 1.调用重写的toString()转换为基本类型 2.数值类型转为字符串类型进行拼接 对象显示转化字符串： 1.调用重写的toString()转换为基本类型Str对象显示转换为数值： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number 相等判断： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number再进行比较-&gt;相等 10. 只重写valueOf的情况下，以上问题会发生什么样的行为变化？1234567输出：1.并没有调用重写的valueOf，而是调用默认的toString()方法，显示[对象 类型]值运算:1.调用重写的valueOf()，转换为基本类型值Number字符串+对象：1.调用重写的valueOf()转换为基本类型值Number 2.转换为str进行拼接 对象显示转化字符串：1.没有调用重写的valueOf()，而是直接调用了默认地toString对象显示转换为数值：1.调用重写的valueOf()转换为基本类型值Number相等判断：1.调用重写的valueOf()转换为基本类型值Number 11. 去掉从Object继承的toString方法的干扰，以上问题会发生什么样的变化？1234567891011121314Object.prototype.toString = null;var cc = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(cc);// 10 valueOfalert(+cc); // 10 valueOfalert(''+cc); // 10 valueOfalert(String(cc)); // 10 valueOfalert(Number(cc)); // 10 valueOfalert(cc == '10'); // true valueOf 因为默认地toString方法没了，所以只能调用重写的valueOf() 总结0.基本上，所有JS数据类型都拥有valueOf和toString这两个方法，null除外。它们俩解决javascript值运算与显示的问题。 还有一个对象没有valueOf()和toString()方法，通过Object.create(null)创建的对象[[Prototype]]属性为null1.toString()用于显示，valueOf()用于值运算。2.默认情况下，根据不同的操作，两个方法的优先级不同。3.在有操作符的情况下，valueOf的优先级比toString高。4.重写会加大它们自动调用的优先级。5.重写toString的情况下，toString()方法会无视valueOf()，1.都会先调用toString()方法转换为基本类型的值，此时如果是”显示”操作就到此为止2.如果是值运算，基本类型的值转化为Number类型进行值运算.6.重写valueOf的情况下，值运算优先调用valueOf，显示地转换为字符串&amp;输出会调用默认地toString()。valueOf()不管返回的是什么基本值，值运算都会对其转换为数值.7.在进行强转字符串的时候将优先调用toString().]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[首先,在了解字符集和字符编码是什么之前先去看看为什么会有字符集和字符编码,它是为了解决什么问题? 字符集的产生我们平时在计算机屏幕上看到的文字内容并不是直接以文字的形式存储在计算机的存储介质中,计算机存储介质中存放的实际上是二进制的比特流。也就是说,不论你在计算机上看到的汉字,英文字母,日文等等,一旦存入计算机存储介质中,最终都是以010101010形式存放。那么如何确保拿出来转换的是汉字不是日文呢?显然,在这两者之间的转换就需要一个统一的规则,不然,当你把文档发给别人,别人的转换规则和你不一样,岂不是就出现乱码了? 所以为了统一转换,字符集就诞生了。简单的说,字符集规定了某个文字对应的二进制数字存放方式(编码)和某串二进制数值代表了哪个文字(解码)的转换关系。 “字符集”就像谍战片中的“译码本”一样,发电报时,大家发送的都是”滴答滴答”的原始信息,但是通过译码本,就可以转换成真实的字符。就像译码本一样,同样的原始信息经过不同的译码本翻译可能得到不同的结果;对于相同的一个字经过不同的译码本转换,翻译出的内容也不一样,这也就是为什么谍战片中大家都这么重视译码本。 对于一个字符集来说要正确编码转码一个字符需要三个关键元素:字库表(character repertoire)、编码字符集(coded character set)、字符编码(character encoding form)。 字库表 是一个相当于所有可读或者可现实字符的数据库,字库表决定了整个字符集能够展示的所有字符的范围。 编码字符集 即用一个编码值code point来表示一个字符在字库中的位置。 字符编码 将编码字符集和实际存储数值之间的转换关系。一般来说都会直接将code point的值作为编码后的值直接存储(ASCII中) 这么看来,字库表和编码字符集看来是必不可少的,既然字库表已经有序号了那为什么不直接把序号作为存储内容呢?干嘛还要多此一举通过字符编码把序号转换成另一种存储格式呢? 因为统一字库表的目的是为了能够涵盖世界上所有的字符,但实际使用的过程中呢,真正用到的字符占字库表的比例是非常低的。比如老美,他们仅仅可能仅仅只用到了ASCII中的128个字符,但是如果都以字库表中的序号来存储的话,原本ASCII中的一个字符只占一个字节,现在一个字符占了三个字节,这显然对他们很不友好。这个时候就出现了UTF-8这样的变成编码。在UTF-8编码中,原本只占一个字节的ASCII字符,仍然只占一个字节。 为什么会有Unicode字符集编码标准?因为ASCII是美国人自己用的,ASCII开始普及之后,各国针对ASCII字符不够自己国家/地区使用,在ASCII上做了扩展,因为此,出现了同一个二进制编码表示不同编码的问题。解决了一个字节不够表示全球中所有符号的问题。 UTF-8和Unicode的关系Unicode就是字符集编码，而UTF-8就是字符编码,就是Unicode规则字库的一种实现形式。unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节)。从unicode到UTF-8并不是直接的对应，而是要过一些算法和规则来转换。UTF-8编码的实现方法，即UTF-8的物理存储和Unicode序号的转换关系。 为什么会出现乱码?编码和解码时使用了不同的字符集。对于字符”很屌”经过UTF-8编码后,它的十六进制表示E5BE88E5B18C这串数字,而我们显示的时候用GBK解码进行展示。(GBK的解码规则是:对于一个字节，如果它是小于127的，那么它就是一个英文单字节。而如果某个字节是大于127，就表示是一个汉字的开始.所以当时会有1个汉字2个英文字符的说法),此时GBK会把这串数字拆成 E5BE 88E5 B18C三组,每组两个字节,所以GBK解码后就成了寰堝睂三个字符。不仅和原来的完全不一样还多了一个。 出现乱码后如何识别原来的想要表达文字? 编码(发现乱码的当前编码,转回二进制) 切割(获取二进制字符串并按字节拆成字节数组) 解码 最后补充一下计算机中存的是二进制,但是常见的用十六进制表示而不用十进制?或者其他八进制?因为二进制过长的数字代码对于阅读带来不便,十进制和二进制没有指数型关系。十六进制简洁且和二进制成倍数关系,两个十六进制就可以表示8个二进制位也就是一个字节。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像程序员般思考]]></title>
      <url>%2F2017%2F04%2F04%2F%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%88%AC%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[平常我们在学习的过程中,比如遇到一个新的术语,新的概念或者所有对于你来说都是未知的”新”东西,你下意识会选择怎么办?我不知道你会怎么办?反正之前的我会先选择维基百科一下看看它是什么(What),然后映入眼前的是大篇幅官方描述,此时如果你有相关领域的经历或者经验(底蕴),很好,轻而易举地理解了它在表述什么,但是如果你之前没有接触过呢?想必看完也是一头雾水。比如socket这个词,你搜词典,它上面的解释”插座,给…配插座”,当然更强大一点的词典,比如有道,它还有网络释义套接字,很好,词典很强大,和维基百科说的也是一样的。 在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 socket是一种操作系统提供的进程间通信机制。[1]socket最初被翻译为把socket译为“媒介(字)”[2]。不久，ARPANET的socket就被翻译为“套接字”，其理由是：[3] 通过这段话,我们得出了几个信息: What:套接字 Do:用于进程间通信 通过这些信息加上我们的”理解”看似已经达到了我们从无到有的认识过程。但这是不属于你的,因为这其实只是凭借着我们大脑的记忆能力强行地进行了一下复制粘贴。这样不牢固的东西是不稳的,就像天龙八部里的慕容复,看似武学渊博,什么都会,名头响亮。但其实他就像一个瓷器,当遇到真正的高手时,就暴露出了问题。因为他无一精通,没有自己的见解,都是照搬别人。但高手之间的对决,往往是变幻莫测的。这就好像我们的程序,完成需求是容易的,难得是维护和迭代。回到socket的问题上,既然是表示网络进程通信为什么不叫Web Communication,这样不更容易理解一下吗?诶,好像这么说也有道理啊,是不是此时感觉之前对socket的理解又动摇了呢?这就是知其然而不知其所以然带来的后果,其实我们真正在看到的一个”新”(可能对于你来说是)的问题时,应该建立这样一个思考问题的过程 为什么会产生这个问题?因为这是人类社会,凡事不会凭空发生,肯定有原因。我觉得了解为什么是拨开神秘面纱的第一步。 其次是How 然后才是What 最后再去建立和别的事物的联系,回头再思考下有什么不足 而对于高明的程序员来说,这其实就是他们的本能的思考和解决问题的行为。 回到socket的产生上,直到我在知乎上看到一篇帖子“Socket为什么要翻译成套接字？”中陈振玥先生的回答才让我反思写下这篇博客记录下——面对于一个未知问题的思考方式。里面大致是这么说的:最早“网络连接”这个词对于那个时代还是一个新兴词汇。当时的网络连接对于大部分人来说是无法理解其含义的,所以作者为了解释清楚,才有了socket,原意想表达的就是建立网络连接就像插插座一样,一方去插,而另一方被插,这就是socket的由来。但是为什么后来变成了套接字呢?这其实更容易理解了,随着发展,大家理解了网络连接的过程,“网络连接”比起早期更复杂了,它被发扬光大了,所以基于这两种情况,插插座这种狭义理解已经不太符合它的定位了。 1. 人类认知的上升 2. 职责的增大 而应试教育和急于求成的心理或多或少地让我们变得浮躁,应试教育让我们的思想变得僵硬,你可以说你在做一道数学题的时候是有在思考问题,但是其实我觉得只能算一半。急于求成的心理往往使我们遇到问题直接询问或者查找如何解决,不加一点地思考,不追根溯源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建静态博客]]></title>
      <url>%2F2017%2F02%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[官方文档：https://hexo.io/github地址：https://github.com/hexojs/hexo主题文档： Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
