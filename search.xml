<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[行内元素的视觉化表现]]></title>
      <url>%2F2017%2F12%2F25%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%A7%86%E8%A7%89%E5%8C%96%E8%A1%A8%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[关键词 盒子模型(box model) 行盒(line box) 行内盒(inline boxes) 行高(line-height)行内元素的垂直对齐(vertical-align) font-size font-family 字体度量 前言:关于行内元素的视觉表现涉及到了很多 CSS 方面的术语,比如:行框,行盒,在不同的书或博客中有使用行框的,有使用行盒的,那么对于刚接触这些概念的我们,往往会有疑问,它们有什么区别?其实是没有区别的,这是由于译者不同的用词习惯导致的,所以今后学习这些新知识有能力最好还是阅读英文文档 译者注：由于不同志愿者的用词习惯，box有时候被翻译成“盒子”，有时候被翻译成“框”。又由于一篇文章有时候由好几位志愿者共同翻译，因此常常在一篇文章中既出现了“盒子”，又出现了“框”，这给读者造成了很大的困扰。在之前几个模块的本地化工作时，我个人认为“框”能更准确表达出box的意思。在W3C上，那里的译者也将box翻译成“框”。但是显然的，“盒子”比“框”更容易区分——“框”容易和“边框（border）”混淆。我在这里特地增加了一个译者注，是希望读者在之后的阅读中能够明白“框”=“盒子”=box，边框=“border”。诸如此类的，padding大部分人翻译成“内边距”，但是padding也有人翻译为“填充”。 来源于 MDN 行盒内元素的排版IFC布局规律 在一个行内格式化上下文中，盒是一个接一个水平放置的，从包含块的顶部开始 这些盒之间的水平margin，border和padding都有效 盒可能以不同的方式竖直对齐：以它们的底部或者顶部对齐，或者以它们里面的文本的基线对齐 什么是行盒(line box) 以及行盒的形成包含来自同一行的盒的矩形区域叫做行盒(line box)也叫行框. line box的高度总是足以容纳它所包含的所有行内框(也叫内联盒子或叫行内盒), 即该行中出现的内联盒子的最高点和最低点的最小框. 换句话说, 行盒的上边界要位于最高内联盒子的上边界, 而行盒的底边要放在最低内联盒子的下边界 line box的宽度由包含块和float情况决定,一般来说,line box的宽度等于包含块两边之间的宽度,然而float可以插入到包含块和行盒边之间,如果有float,那么line box的宽度会比没有float时小 特点: 每一行都是一个行盒, 同一段文本从一行变成多行, 行盒的个数也会发生变化. 行盒模型(line box)和行内元素的盒模型(inline box)不是一个东西, 行盒模型这个盒子实际是看不到的, 他仅仅是由一行行内元素所确定的这么一个东西. line box的高度由line-height决定,但不总是等于某个最高的行内元素的 line-height, 因为行内元素的 vertical-align 会影响行内元素的对齐方式而导致最高的行内盒子的底部不一定是 line box 的底部,如上图. 12345这里也解决了一个困扰自己的问题: 行盒的定义:&lt;code&gt;line box&lt;/code&gt;的高度总是足以容纳它所包含的所有行内框 行盒的高度: 由 line-height 决定(即以为行盒的高度 = 一行内最大的 line-height) 但是现在有一张图片(行内替换元素)和文字(行内非替换元素),line-height 为50px, 那么行盒的高度是不是和行盒的定义冲突了??? 50px &lt; 100px, 行盒怎么能包含图片呢? 其实对于行盒的定义没错,只是行盒的高度并不由line-height决定!!! line box之间的高度各不相同(比如只含文本的line box高度与包含图片的line box高度之间) 行盒的高度是根据子元素的高度来计算,注意这里子元素的高度并不是子元素内容区域(content-area)的高度,这是有很大区别的. 尽管这听起来可能有些奇怪，行内元素有两个不同高度：content-area(内容区域）高度和virtual-area(虚拟区域）高度（这是我发明的术语virtual-area高度，你在规范中是找不到任何相关的内容）. content-area高度是由font-family,font-size来决定的. virtual-area高度是line-height，它的高度用于计算line-box的高度.只是计算,并不等于 当一行的行内级盒的总宽度小于它们所在的line box的宽度时，它们在行盒里的水平分布由text-align属性决定。如果该属性值为justify，用户代理可能会拉伸行内盒（不包括inline-table和inline-block盒）里的空白和字（间距） 行内盒(inline box) 一个inline box是一个（特殊的）行内级盒，其内容参与了它的包含行内格式化上下文 当一个inline box超出一个line box的宽度时，它会被分成几个盒，并且这些盒会跨多line box分布。如果一个inline-block无法分割（例如，如果该inline box含有一个单个字符，或者特定语言的单词分隔规则不允许在该inline box里分隔，或如果该inline box受到了一个值为nowrap或者pre的white-space的影响），那么该inline box会从line box溢出 当一个inline box被分割后，margin，border和padding在发生分割的地方（或者在任何分割处，如果有多处的话）不会有可视化效果 同一个line box里的inline box也可能因为双向（bidirectional）文本处理而被分割成几个盒 1.盒子的生成inline 元素(span, 图片, 文字…)生成各种 inline boxes, 其内容参与了它的包含行内格式化上下文 2.盒子的高度计算(line-height登场)包括行内非替换元素和行内替换元素的高度计算 3.盒子的摆放(vertical-align登场)3.1 当设置 vertical-align 属性的时候,谁和谁对齐?对于行盒的 baseline 如何确认? 该属性会影响由一个行内级元素生成的盒的行盒内部的竖直定位 默认情况下,inline,inline-block以及table-cell可以应用vertical-align 3.1.1 这里反复提到父级盒的基线,那么这个父级盒是指 包含块元素 还是 行盒?3.1.1.1 如果父级盒是指块级盒对于包含块,即使没有显示地设置字体属性,它也是有自己的字体的(默认是serif),字体有了那么它的基线位置就确认了,line-height 有了,那么这个字体的内容形成的一个匿名inline box的高度也就有了,那么line box内所有inline box的参照物也就有了 3.1.1.2 如果父级盒是指行盒(《CSS 权威指南》195页中父级盒就是指行盒),这里父级盒如果是指line box,困扰自己最大的问题是:一个行框内有多个行内框的时, 行框的基线如何确定? 注意 vertical-align:middle属性的表现与否，仅仅与其父标签有关，至于我们通常看到的与后面的文字垂直居中显示那都是假象！ 如何理解:因为改变图片的vertical-align属性以后,图片位置会上移或下移,而文字在那里却纹丝不动!,这说明什么?说明vertical-align: middle 带来的图文对齐效果是顺带的,与后面的行内水平的元素不存在直接关系,具体地分析见张鑫旭老师的 vertical-align 属性是如何起作用的 3.2 没有基线的inline box 如何对齐?比如对于行内替换元素img 对于 行内替换元素(比如img)的基线就是其margin底边缘 对于 inline- block 元素比较复杂:一个inline- block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线,具体地看张鑫旭老师的 inline-block和baseline 4.行盒的确立(定行高)可以通过这个过程来了解一行的各部分如何共同确定其高度 确定行中各inline box的高度(注意: inline box的高度 ≠ 内容区域的高度) 对于可替换元素(比如img,svg,input),inline-block元素和inline-table元素占据的高度(即inline box 高度) ,这个值就是其margin box的高度,如果hegiht的值是auto，然后使用line-height时content-area严格上等于line-height. 对于非替换元素 inline box 占据的高度不由行高决定,而是内容区域和行间距,只不过,正好 content area + vertical spacing = line-height,所以我们就可以认为行高就是非替换元素形成的 inline box 的高度,就像欧姆定律可以计算出电阻,但不能说电压和电流决定了电阻. 内容区域(content area)是一种围绕文字看不见的盒子. content-area 和 font-size 以及 font-family 相关, 和 line-height 没有任何关系 关于em盒子也叫 em 框 模型,其实就是字体的容器,这个属于 content-area ,这也是为什么算 content-area 的时候即使不算vertical spacing(行间距),文字仍然有上下左右留白的原因. 如果 line-height 没有指定值,如何计算?没有指定值的 line-height 是有默认值的,默认值为 normal ,而 normal 在不同的浏览器,不同字体下的值是不同的.为了计算出 line-height 的具体值, 我们需要知道 normal 对应的值,然后乘以 font-size 即可求出行内元素的行高. normal 的计算: 设置字体的 font-size 为100px, 方便计算 通过 Chrome 的检查工具获取行内元素的高度,此时因为行内没有别的 font-family 的元素,所以vertical spacing 为0,即 行内元素的高度表现 = content-area = line-height 高度 / font-size = 该字体normal 值对应的数值 补充vertical spacing的值可大可小,还可以为负,它的作用只是保证行内盒子的高度正好等同于行高 2.确定替换元素的高度 得到各替换元素的 height margin-top margin-bottom padding-top padding-bottom border-top-width border-bottom-width的值,把它们加起来 3.取该行内最高盒子的ine-height形成高度 3.line box的高度等于最高inline box的上边界加上最低inline box的下边界,或者说是 父级盒基线的位置到最高inline box的上边界的距离加上父级盒基线的位置到最低inline box的下边界的距离. 3.通过行高定基线,基线确定别的线 对于各内容区,确定它在整行基线的上方和下方分别超出多少.这个任务并不容易:你必须知道各元素及匿名文本各部分的基线的位置,然后让它对齐该行基线.另外,对于替换元素,要将其底边放在整行的基线上 《CSS 权威指南》 注意:这段是根据父级盒指行盒产生的理解.即先定行盒的基线再摆放元素,但是这有一个最大的问题,盒子未摆放之前,行盒根本无法确立,所以删掉了这段 4.vertical-align 修饰细节注意:这段和上一段是一起的,即确立行盒=&gt;确立行盒的基线=&gt;盒子根据默认的对齐方式对齐=&gt;vertical-align进行细节修饰,但是这也存在上面一样的问题:盒子未摆放之前,行盒根本无法确立.并且修改vertical-align会影响行盒的高度,行盒被修改了,那么行盒的基线肯定发生变化造成循环影响,所以删除掉了这段 对于指定了 vertical-align值的元素,确定其垂直偏移量,由此可知该元素的内联盒子要向上或向下移多远,并改变元素在基线上方或下方超出的距离 5.计算多行文本的高度所有line boxes 的行高加起来,即为行内元素的高度表现. 5.1 结论所以一个没有设置height属性的包含块高度就是由一个一个line boxes的高度堆积而成的。 6.影响 line box 高度的因素 line-height通过影响inline box的高度影响line box的高度 不同的font-family的文字通过baseline位置的不同,影响盒子的对齐而会影响line box的高度 font-size通过影响数值单位的line-height影响line box的高度 vertical-align影响inline box的对齐方式,影响line box的高度 特别注意的是, 设置inline元素的垂直距离无法改变行盒的高度, 视觉表现为文字还待在该待的地方,即垂直方向上的margin、padding、border是不占据空间的,但是唯一和块元素表现相同的是margin还是透明色，padding、border还是能够显示背景色的。同时由于对html文档的渲染是从上到下的，所以可能存在后面的行内元素的垂直方向的背景色覆盖前面的元素，对后面的元素中文字部分不会覆盖。 6.1 line-box计算的小细节： 对于行内非替换元素，padding和border增加了其background区域，但不会增加内容区域高度（甚至是line-box高度）。因此，你在屏幕上看到的不一定就是内容区域。margin-top 和 margin-bottom 对内联元素不生效。 对于行内替换元素，inline-block和blocksified行内元素，padding，margin和border都会增加高度，所以内容区域和line-box的高度也会增加 7.补充由于以上例子中使用到的字体可能在用户的系统里并不存在,然后发现设置不同的font-family失败,可以参考: 浏览器默认支持哪些字体(1) Mac如何给自己下载字体(2) 更多关于CSS来控制字度的度量指标的问题,请参考大漠老师翻译的深入了解CSS字体度量，行高和vertical-align 下面来看几个实际开发中遇到的问题图文混排123456789101112131415&lt;style&gt; div&#123;border:1px solid #ccc;&#125; a &#123;border: 1px solid;text-decoration: none&#125; a:hover &#123;color: yellow&#125; span &#123;padding: 30px;background-color:red;margin: 20px;border: 1px solid blue;&#125; img &#123;width: 50px;height: 50px;margin: 10px;&#125; .a &#123;font-size: 30px;line-height: 100px;&#125;&lt;/style&gt;&lt;div&gt; &lt;a href="#"&gt; &lt;img src="http://www.baidu.com/img/bd_logo1.png" alt=""&gt; &lt;span&gt;x&lt;/span&gt; &lt;span class="a"&gt;x&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 信息: 包含块不设置高度 inline 元素嵌套并不会让 inline 盒子嵌套 line box内包含 替换元素(img),不同 font-size 和 line-height 的 inline box 默认的vertical-align 对于不可替换的行内元素,width和height这两个属性是不能描述一个不可替代的行内元素的，所以说一直都是默认值auto. 图文混排的包含块高度 行内元素在盒模型中的表现: 按照盒子的生成=&gt;盒子的高度计算=&gt;盒子的摆放=&gt;行盒的确立 包含块高度112px,行高100px, 说明line box的高度不等于line box内最高 inline box的高度,并且line box的高度并不由line-height决定 112的由来:包含块2px 的 border,以及line box的高度,其中上边界是 img元素的 margin-top,下边界是.a的inline box的 bottom 2. 不同 font-family 的 inline box 高度表现123456789&lt;p&gt; &lt;span class="a"&gt;Ba&lt;/span&gt; &lt;span class="b"&gt;Ba&lt;/span&gt; &lt;span class="c"&gt;Ba&lt;/span&gt; &lt;/p&gt; p &#123; font-size: 100px; &#125; .a &#123; font-family: Helvetica; &#125; .b &#123; font-family: Gruppo; &#125; .c &#123; font-family: Catamaran; &#125; 信息: 包含块盒子不设置高度 默认的 line-height 相同的 font-size 默认的 vertical-align 可以发现包含块的高度为164px,刚好是font-family: Catamaran的inline box的content-area,(在不指定行高的情况下,content-area 等于 line-height 的值,而在不指定竖直方向的padding,border的情况下,通过 Chrome 面板获取的元素占据尺寸就是 content-area的值,如图) 包含块不设置高度时的高度表现 不设置竖直方向的 padding,border 实元素的占据尺寸 带 padding 和 border的元素的占据尺寸 参考 《CSS 权威指南》 css行高line-height的一些深入理解及应用 by 张鑫旭 深入了解CSS字体度量，行高和vertical-align by 大漠 你真的了解行盒模型吗 行内格式化上下文(Inline formatting contexts)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式学习总结]]></title>
      <url>%2F2017%2F12%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[关键词 精确匹配 模糊匹配 位置匹配 重复出现 分组 捕获 反向引用 片段匹配 捕获的引用 邮箱验证 敏感词屏蔽 字符串修剪 心得 又叫规则表达式，它是用代码来准确表述一些我们语言上描述的规则，比如：用代码描述多个0，其中多个0就叫模式，规则 谈正则肯定离不开字符串 正则表达式最难理解的地方在于等价这个概念，这个概念增加了理解难度，如果把等价都恢复成原始写法，自己书写正则就超级简单了，就像说话一样去写你的正则了 正则表达式除了匹配字符以外，还可以匹配位置 指定匹配的位置(实际上就是为了不断章取义) 我们已经看到了,一个正则表达式中的许多元素才能够匹配字符串的一个字符.例如: \s 匹配的只是一个空白符.还有一些正则表达式的元素匹配的是字符之间宽度为0的空间,而不是实际的字符例如: \b 匹配的是一个词语的边界,也就是处于一个/w字字符和一个\w非字字符之间的边界.像\b 这样的字符并不指定任何一个匹配了的字符串中的字符,它们指定的是匹配所发生的合法位置.有时我们称这些元素为正则表达式的锚.因为它们将模式定位在检索字符串中的一个特定位置.最常用的锚元素是 ^, 它使模式依赖于字符串的开头,而锚元素$则使模式定位在字符串的末尾. 例如:要匹配词 “javascript” ,我们可以使用正则表达式 /^ javascript $/. 如果我们想检索 “java” 这个词自身 (不像在 “javascript” 中那样作为前缀),那么我们可以使用模式 /\s java \s /, 它要求在词语java之前和之后都有空格.但是这样作有两个问题.第一: 如果 “java” 出现在一个字符的开头或者是结尾.该模式就不会与之匹配,除非在开头和结尾处有一个空格. 第二: 当这个模式找到一个与之匹配的字符时,它返回的匹配的字符串前端和后端都有空格,这并不是我们想要的.因此,我们使用词语的边界 \b 来代替真正的空格符 \s 进行匹配. 结果表达式是 /\b java \b/.下面是正则表达式的锚字符:字符 含义 ^ 匹配的是字符的开头,在多行检索中,匹配的是一行的开头 $ 匹配的是字符的结尾,在多行检索中,匹配的是一行的结尾 \b 匹配的是一个词语的边界.简而言之就是位于字符\w 和 \w之间的位置(注意:[\b]匹配的是退格符) \B 匹配的是非词语的边界的字符 正则表达式的特点 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。 规则总结 正则表达式中最小单位是字符 反斜杠(\ )总是对后面的字符起作用 大括号({})总是对前面的字符表达式起修饰作用 PS： 关于字符与表达式的区别，用表达式更准确，因为如果存在分组的情况时，大括号作用的目标就是一个单元而非一个字符 问号，加号，星号(? + *)就是大括号的特殊情况，也就是等价写法 中括号([])不是对前面和后面起作用的，而是占了一个字符的位置 小括号()的作用很强大 分组: 被小括号包裹的n个字符会被视为一个字符(专业术语:单元),这样可以方便? + *的整体匹配 在完整模式中定义子模式：(场景：一堆图片要重命名,文件名是截屏图片xxx2016,我们要把2016改成2017，首先我们不能直接找2016，因为这样的话会找到别的带有2016字样的文件，所以我们肯定是先匹配所有的”截屏图片xxx2016”这个模式，也就是完整模式,然后通过这个模式下再去找我们要的核心:2016，最后再进行替换操作,而2016就是子模式) 引用：用()分组以后，再后面用反斜杠+数字可以取得对前面小括号的引用，注意：引用的不是模式而是相同的文本 |：竖线不单独对一个字符起作用，而是划分选项(专业术语:指定分组项),要么是左边的表达式，要么是右边的表达式 ()是为了提取字符串，[]定义范围，{}定义长度 常用的特殊元字符以及在正则表达式种的行为 正则表达式种不能用空格匹配空格，需要用\s匹配空格 Q：什么是贪婪模式？所谓贪婪模式，就是满足匹配条件的情况下，会尽可能多地匹配所搜索的字符串。例如，对于字符串 ‘oooooo’ ，’o+?’ 将匹配单个’o’，而 ‘o+’ 将匹配所有的o。 这是为什么？这就是 ？号的特殊用法，当它放在其他量词(*, +, ?, {n}, {n,}, {n,m}) 后面，会取消贪婪模式，即尽可能少地进行匹配 正则表达式的应用场景配合字符串使用 检查字符串中是否包含指定的模式，常用于：替换操作的第一步 | 邮箱验证【1】模式：简单理解就是检查字符串中是否包含指定的值，这里用模式这个词更准确，因为它可以表示用于泛指，模糊匹配，范围更广，比如是否包含多个0，这句话用代码就不能用指定的值来表示，因为1个0也是0，多个0也是0 RegExp.test(String)返回布尔值true/false，在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，这个方法非常有用。 String.search(RegExp) 返回-1/位置 用指定的文本替换正则模式匹配到的文本，常用于：敏感词过滤，各种文本插值语法，高亮显示String.replace(RegExp, String2) 这里返回的是一个新的字符串 其他的方法： RegExp.exec(String) ：返回字符串符合模式匹配的值，如果没有，返回null，一般这个方法用得少，检查是否有值用test，替换值用replace，对指定的部分替换用捕获组的方式。 String.match(RegExp) ：如果具有选项g则找出所有匹配项，如果没有选项g，则会返回包含第一个匹配项的信息的数组，捕获组，整个匹配从0开始的索引，以及被解析的原始字符串。 如何用文字表达正则语法？字符串；tel:086-0666-88810009999 原始正则：”^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$” 速记理解：匹配开始 “tel:普通文本”[0-9数字]{1至3位}”-普通文本”[0数字][0-9数字]{2至3位}”-普通文本”[0-9数字]{8至11位} 结束” 等价简写后正则写法：”^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$” Q: 为什么 RegExp.$1 就指代了 /y+/?描述： 为什么RegExp这个构造函数能知道我要的捕获组？我并没有以如下的方式获取捕获组，为什么就可以得到这个捕获组了呢? 123let pattern = /(y+)/ // 定义一个模式let matches = pattern.exec(fmt)let captureGroup = matches[1] // 获取捕获组 如图：高程上是这么说的: 5.4.3 RegExp构造函数属性RegExp构造函数包含一些属性（这些属性在其他语言中被看成静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名 当然，除了这些属性以外，还有9个用于存储捕获组的构造函数属性，访问这些属性的语法是 RegExp.$1、 RegExp.$2、 RegExp.$3…… RegExp.$9，在调用exec()或test()方法时，这些属性会自动被填充。 从上面已经找到了我们想要的答案： RegExp构造函数包含一些静态属性 静态属性的值基于所执行的最近一次正则表达式操作而而变化，比如exec()或test() RegExp.$1访问到的就是最近一次正则表达式操作的捕获组内容 12345678910111213141516171819202122let text = "this has been a short summer"let pattern = /(.)hort/gif(pattern.test(text)) &#123; console.log('获取最近一次要匹配的字符串: ' + RegExp.$_) console.log('获取最近一次的匹配项: ' + RegExp.lastMatch) console.log('获取最近一次匹配的捕获组: ' + RegExp.lastParen) console.log('获取字符串最近一次匹配之前的文本:' +RegExp.leftContext) console.log('是否所有表达式都使用了多行文本: ' + RegExp.multline) console.log('获取字符串最近一次匹配之后的文本: ' + RegExp.rightContext) console.log('通过RegExp获取捕获组: ' + RegExp.$1) console.log('通过RegExp获取捕获组: ' + RegExp.$2)&#125;// 获取最近一次要匹配的字符串: this has been a short summer// 获取最近一次的匹配项: short// 获取最近一次匹配的捕获组: s// 获取字符串最近一次匹配之前的文本:this has been a// 是否所有表达式都使用了多行文本: undefined// 获取字符串最近一次匹配之后的文本: summer// 通过RegExp获取捕获组: s// 通过RegExp获取捕获组: // 因为没有第二个捕获组，所有没有填充值 模式对象的实例属性 尤其注意实例属性和静态属性的区别 通过这些属性可以取得有关模式的各种信息 是否设置了 g 修饰符? =&gt; pattern.global 是否设置了 i 修饰符? =&gt; pattern.ignoreCase 是否设置了 m 修饰符? =&gt; pattern.multiline 获取正则表达式的字符串表示 =&gt; pattern.source 查找/设置开始搜索下一个匹配项的字符位置 =&gt; pattern.lastIndex 注意,这里从字面理解起来可能会有困惑,最后的索引? 指的是下次开始搜索匹配项的起始字符位置 注意,这个行为仅仅在具有修饰符的模式对象中有用,比如g,y(es6新增),在没有修饰符的模式对象中会忽略这个变化,即获取/设置不具有修饰符的模式对象的lastIndex属性,会被忽略. 注意,只有调用exec()和test()这些模式对象的方式 lastIndex 属性才会发生改变;调用字符串的方法,比如match方法,lastIndex 属性不会发生改变. ES6对正则表达式的修复和增强修复1 原本( ES5 )的正则表达式无法对码位(code point)大于 0FFFF 的字符进行匹配,会匹配不上,因为对于码位大于 0FFFF 的字符需要用2个码位(或者说字符)去表示一个字符(指码位大于0FFFF 的字符),但是正则表达式却不知道这回事,它依然会认为这2个码位表示2个字符而不是码位大于 0FFFF 的字符,这是因为正则表达式默认操作模式是编码单元(code unit)操作模式. 用2个码位(编码单元)表示1个字符(或者说一个码位)的术语就叫代理对 那么 ES6 怎么修复这个问题呢?ES6引入了修饰符u, 含义为开启Unicode 模式,如此一来模式对象就不会视代理对为2个字符了.其实这里应该不少人和自己一样有个疑问:我怎么知道什么时候2个字符是映射一个单字符而不是2个单字符?这里在自己查阅资料后得到了理解,即代理对的定义:如果第一个值来自于高代理区(D800–DBFF),并且第二个值来自于低代理去( DC00-DFFF),那么这就是一个代理对,即2个字符映射一个辅助平面(supplementary plane)或者说码位大于 0*FFFF 的字符. 1234let text = '𠮷';/^\uD842/.test('\uD842\uDFB7') // true /^\uD842/u.test('\uD842\uDFB7') // false /^\uD842/.test(text) // true 第二行代码说明了 JavaScript 正则表达式对象默认的操作模式-编码单元(也可以叫不认识代理对模式),\uD842\uDFB7即代理对表示汉字”吉”,但是正则表达式并不认识代理对,仍把它当成2个字符,所以第二行结果是true(当成单字符匹配),而使用修饰符u后,正则表达式就会开启 Unicode 模式,即拥有识别代理对的能力,目标字符串如果存在代理对就会有类似添加小括号的行为(便于理解)，即(\uD842\uDFB7),显然此时模式\uD842并不匹配(\uD842\uDFB7),所以第三行代码结果为false。第四行的结果为 true, 可以看出对于模式匹配字符串,字符串首先会默认转换为编码单元再进行模式匹配. 以上示例,我们学到了什么? 模式匹配的时候,字符串会转换成对应的编码单元 使用了u修饰符,则会开启 Unicode 模式,此时如果字符串中存在代理对,会被正确识别 使用了u修饰符,并不影响模式本身,即/\^\uD842/u和/\^\uD842/仍然匹配\uD842这个字符,只是如果这个字符在目标字符串中不表示自身,而是作为代理对的一部分,这两种模式就会存在是否正确识别的差异. 修复2 正则表达式的复制增强1 粘连修饰符 y粘连(sticky)修饰符,何为粘连修饰符?这就不得不提到 g 修饰符了,如果默认的不带 g 修饰符,每次匹配会重新从字符串开始的位置匹配,我称之为无状态匹配.但是 g 修饰符会从上一次匹配成功的下一个位置开始,即剩余字符串开始匹配,而 y 修饰符和 g 修饰符类似,也是如此,不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的含义。 1234567891011121314let s = 'aaa_aa_a';let pattern1 = /a+/; let pattern2 = /a+/g; let pattern3 = /a+/y; // 第一次匹配pattern1.exec(s); //['aaa']pattern2.exec(s); //['aaa']pattern3.exec(s); //['aaa']// 第二次匹配pattern1.exec(s); //['aaa']pattern2.exec(s); //['aa']pattern3.exec(s); //null 第一次匹配的结果都一样,因为都是从目标字符串的开头进行匹配,而第二次匹配的结果却各不相同,因为不带修饰符的模式匹配是无状态匹配,即每次都从目标字符串的开头重新匹配,而带有修饰符 g 和 y 的则会记住上次匹配完时的位置,下次匹配时候从剩余字符串的开头继续匹配,而 y 修饰符返回为 null 是因为 y 暗含了\^语义,而 g 修饰符则没这个语义,只要在剩余字符串中能匹配到模式即可. 12345678910111213141516// y 修饰符与lastIndex属性const REGEX = /a/y;// 指定从2号位置开始匹配REGEX.lastIndex = 2;// 不是粘连，匹配失败REGEX.exec('xaya') // null// 指定从3号位置开始匹配REGEX.lastIndex = 3;// 3号位置是粘连，匹配成功const match = REGEX.exec('xaxa');match.index // 3REGEX.lastIndex // 4 从上面这2个示例,我们学到了什么? y修饰符暗含了\^的语义. y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 模式对象的lastIndex属性可以影响模式匹配时从目标字符串的哪个位置开始匹配. 增强2 flags 属性在 ES5中,我们无法直接获取一个模式对象的修饰符,那么在 ES5中我们是如何做的呢? 注意:模式对象的source属性只能获得模式的文本而不能获得修饰符 123456789function getFlags(re) &#123; let text = re.toString() return text.substring(text.lastIndexOf('/')+1, text.length);&#125;// toString()的返回值为 "/ab/g"let re = /ab/g;console.log(getFlags(re)); // 'g' 为了使获取修饰符的过程更简单, ES6新增了一个flags属性,它与source属性都是只读的原型属性访问器,对其只定义了 getter 方法,访问这个属性会返回所有应用于当前模式对象的修饰符字符串. 增强3 sticky 属性与y修饰符相匹配，ES6 的正则对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于文件拓展名的误区]]></title>
      <url>%2F2017%2F10%2F21%2F%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E6%8B%93%E5%B1%95%E5%90%8D%E7%9A%84%E8%AF%AF%E5%8C%BA%2F</url>
      <content type="text"><![CDATA[关键词 拓展名 起源Linux下的重定向命令 &gt; ，这个命令的作用是把结果输入到一个文件里面去，如果文件不存在则创建，有则覆盖。重定向又叫管道定向命令，常用于统计数据中。 这里就会纠结一点： 写入数据一定是写入到记事本吗？文件后缀很重要吗？ 其实不是这样的，文件的后缀名随便写，就像你写一个 .mp3 ，就一定是一个mp3了吗？答案显然是否定的，它一样可以用记事本打开。 这个思路给了我们一个隐藏文件内容的新思路，可以通过记事本打开特定的文件，删改并记住指定位置的字符，这样文件就会以破损的方式无法打开，而下次我们需要打开的时候只需要在特定的位置改回去就可以使用了。 不同类型文件的判定机制其实程序根本不靠后缀来判断，靠里面文件头的第多少个字节，里面有一个信息来表明它是什么文件类型。如果把文件头破坏的话，整个文件都可能被毁坏掉。 关于文件拓展名的权威分析文件的扩展名是早期操作系统（如VMS/CP/M/DOS等）用来标志文件格式的一种机制。文件扩展名更重要的作用是让系统决定当用户想打开这个文件的时候用哪种软件运行，如Windows系统中exe文件是可执行文件，doc文件默认用Microsoft Word打开的Word文件。 但是这会形成一个误区：比如.png的后缀一定是一张图片吗？ 误区1：文件扩展名是一个文件的必要构成部分。 一个文件可以有或没有扩展名。对于打开文件操作，没有扩展名的文件需要选择程序去打开它，有扩展名的文件会自动用设置好的程序（如有）去尝试打开（是“尝试打开”，而不是“打开”的原因参看下面的第2个误区），文件扩展名是一个常规文件的构成部分，但一个文件并不一定需要一个扩展名。 误区2：二、文件扩展名表明了该文件是何种类型。 虽然文件扩展名表明了该文件是何种类型，但是他可以被人为地设置。就像一张.png的后缀名一定是一张图片吗？其实不是这样的，所有的文件都可以文本形式打开，文件扩展名可以人为设定，扩展名为TXT的文件有可能是一张图片，同样，扩展名为MP3的文件，依然可能是一个视频。 拓展名与病毒可以这么说：有些木马文件（可运行的，扩展名为exe）会伪装成图片文件（经常）或其他的文件。比如有一木马文件为：hack.jpg.exe，它的图标也是jpg图片的图标，如果你选择了隐藏文件扩展名，那显示为hack.jpg，且图标是图片的，那你就很容易上当，双击它的话，就是运行了一个木马程序.有些更毒的，它还绑定了图片，双击这类文件时，会出现一个图片，但木马程序已悄悄地在后台运行安装了，而你又以为真的是一张图片而已.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码之3XX]]></title>
      <url>%2F2017%2F10%2F21%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%B9%8B3XX%2F</url>
      <content type="text"><![CDATA[关键词 HTTP 重定向 前言3XX 状态码都是重定向相关，但是不同的3XX有着不同的区别，导致使用场景上的区别，当我们设置重定向的时候，这点尤为重要。之前做了个服务器处理表单的代码，体会到了不同状态码的区别。 123456789101112// 添加中间件处理POST请求表单app.use(require('body-parser')());app.get('/newsletter',(req, res) =&gt; &#123; res.render('newsletter',&#123;csrf: 'CSRF token goes here'&#125;);&#125;);app.post('/process',(req, res) =&gt; &#123; console.log('Form (form querystring): ' + req.query.form); console.log('CSRF token (from hidden from field): ' + req.body._csrf); console.log('Name (from visiable from field): ' + req.body.email); res.redirect(303, '/thanks-you'); // 这里用到了重定向&#125;); 301 和 302，303的区别在一般表单提交中，我们往往通过重定向的方式提供一个新的视图，而如果不通过重定向的方式渲染视图，访问者的地址栏仍旧不会变，这是不好的。在这种情况下使用 303(或 302) 重定向，而不是 301 重定向，这一点非常 重要。 301 重定向是“永久”的，意味着浏览器会缓存重定向目标。如果使 用 301 重定向并且试图第二次提交表单，浏览器会绕过整个 /process 处理程序直接进入/thank you页面，因为它正确地认为重定向是永久性的。另一方面， 303 重定向告诉浏览器“是的，你的请求有效，可以在这里找到响应”， 并且不会缓存重定向目标。 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已经被分配到了新的 URI ，以后应该使用资源所指向的 URI 。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 理解：显然301这种重定向适用于的场景不适合表单跳转，而是需要更换域名或有多个域名指向一个网站。或者多个网站想合并到一个主域名。比如新浪微博就是有多个域名： 12t.sina.com.cnweibo.com 为什么一定要用301跳转？如果使用head标签内meta refresh或者JS跳转或302转向,这样很容易被百度或其他搜索引擎视为作弊被惩罚降权。这时要是用301重定向。 百度收录的地址大部分是旧域名下的链接，此时相当于流量和权重都在旧域名，那么主域名就很不划算，要做301转向。 原域名被百度k掉，要做301重定向。什么意思，就是说，旧域名被k，会有很长时间不被收录，那么启用新域名，把原来的域名做301转向即可。 PS：有www和无www域名：www.gw020.com 和gw020.com 其实是2个不同的域名，就是说带有www的域名其实只是个二级域名。因为非常常用，所以习惯必须有www。而对于搜索引擎来说，这是2个域名，所以会出现经常是没有www的域名被收录很多，而有www的域名没有被收录，或者收录量完全想法或不同。如果很在意这个流量转化和权重集中，可以把其中一个做301重定向。方法同上。 302 Found 302状态码主要是提示该次为临时重定向，故而除非特别指定了缓存头部指示，该状态码不可缓存。对于服务器，通常会给浏览器发送HTTP Location头部来重定向到新的新位置。 那么言下之意是什么呢？就意味着资源不是被永久移动，已移动的资源的URI将来还可能发生改变。 302状态码的特征其特征被定义为： 客户端收到的新的 URI，不是原始请求资源的替代引用。只有当服务器发出 Cache-Control 或 Expires 头字段进行指示，此响应才能被缓存，否则不能被缓存。 临时URI应该由响应头部中的 Location 字段给出。除非请求方法是 HEAD ，否则响应的实体应该包含一个带有超链接到新的URI的短 HTML 注释。 如果在除 GET 或 HEAD 两种请求方法之外的请求时，接收到302状态码，客户端不得自动重定向请求，除非用户可以确认；否则可能会更改发出请求的条件。 如果一个客户端有链接编辑能力，其应当把所有的引用链接重定向到新的URL上。 重定向到新地址时，客户端必须使用GET方法请求新地址。 从维基百科中看到并不推荐使用302状态码，这是为什么呢？ 302 重定向和网址劫持（URL hijacking）302 重定向和网址劫持（URL hijacking） 为什么不推荐使用，但还是存在302呢？虽然 RFC 1945 和 RFC 2068 两个规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为 303响应 ，并且径自使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法，这是不规范的实现。 因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303和307的由来 从上面的介绍可以知道，HTTP1.1和HTTP1.0的302状态码意义是一样的，浏览器对它的处理也是一样的。POST方法的重定向在未询问用户的情况下就变成GET，这种不符合文档规范的问题依然存在。实践在前而文档在后，HTTP1.1把这种POST变GET的行为纳入了RFC文档：HTTP1.1新加入303和307状态码。 文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。 HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。 总结303和307是HTTP1.1新加的服务器响应文档的状态码，它们是对HTTP1.0中的302状态码的细化，主要用在对非GET、HEAD方法的响应上。文档规定：浏览器对303状态码的处理跟原来浏览器对HTTP1.0的302状态码的处理方法一样；浏览器对307状态码处理则跟原来HTTP1.0文档里对302的描述一样。 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。 在HTTP1.1中，302理论上是要被放弃掉的，它被细化为303和307，但为了兼容，它目前还在业界中大量使用，而303和307状态码我还没遇到过（没有使用场景，也没抓到过这样的响应报文）。为什么业界少使用303和307呢？对于GET和HEAD方法来说，307是没必要存在的，用302或者303就可以满足需求了，307仅在POST方法的重定向上有用处。所以我猜测它们少见的原因有两方面：1、POST方法重定向的使用场景太少，使得307状态码没有用武之地；2、GET方法虽然常需要使用的重定向，但使用302状态码也能正确运转，再考虑到微乎其微的兼容问题（现在的浏览器怎么可能不支持HTTP1.1呢！），也就没有使用303的必要了。 参考： 《图解HTTP协议》 维基百科 - HTTP - 302 何时应该使用301重定向？ HTTP状态码302、303和307的故事]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux起源]]></title>
      <url>%2F2017%2F10%2F19%2FLinux%E8%B5%B7%E6%BA%90%2F</url>
      <content type="text"><![CDATA[关键词 Linux Unix 起源 Linux、Unix的关系提到Linux的起源，不得不提到Unix，因为本质上Linux是一个类Unix系统。MIT[麻省理工学院]有一个可供30个人同时使用的分时操作系统。但是在那个时候，30个人并发太少了，当时的计算机非常贵，只有30个人能用终端登录到计算机使用远远不够，于是在1965年，由贝尔实验室（Bell Labs）和MIT决定要让30个人的分时操作系统提高到300人同时使用，并且把这个称之为MULTICS计划。 这个计划经历了4年时间，到了1969年，由于进度过慢，MULTICS计划失败了。虽然计划失败了，但是Ken Thompson（后被称为UNIX之父）却并没有把MULTICS计划精华部分的代码丢弃，他在这个基础之上开发了一个file server system[文件系统] ，并且在贝尔实验室受到了广泛的欢迎和使用。 到了1973年的时候,Ken Thompson 与Dennis Ritchie成功地用C语言重 Unix Unix 写了Unix的第三版内核。至此，Unix这个操作系统修改、移植相当便利，为Unix日后的普及打下了坚实的基础。 Unix出现以后最大的影响在于开源代码，它把源码内核共享，而几家大公司基于Unix的开源代码的二次开发，于是IBM基于此开发了一个 AIX 的 类Unix 操作系统；Sun公司基于此开发了一个 solaris 的操作系统；HP公司开发了一个 HP-UX 操作系统；而苹果公司基于此开发了 A/UX 的类Unix系统… 所以关于Unix和Linux的关系可以这么理解： Unix是一个很大的范畴，就像我们今天说去吃炒菜，炒菜就是一个类别，大的范围。Linux继承自Unix Unix特性 UNIX系统是一个多用户，多任务的分时操作系统。 UNIX的系统结构可分为三部分：操作系统内核（是UNIX系统核心管理和控制中心，在系统启动或常驻内存），系统调用（供程序开发者开发应用程序时调用系统组件，包括进程管理，文件管理，设备状态等），应用程序（包括各种开发工具，编译器，网络通讯处理程序等，所有应用程序都在Shell的管理和控制下为用户服务）。 UNIX系统大部分是由C语言编写的，这使得系统易读，易修改，易移植。 UNIX提供了丰富的，精心挑选的系统调用，整个系统的实现十分紧凑，简洁。 UNIX提供了功能强大的可编程的Shell语言（外壳语言）作为用户界面具有简洁，高效的特点。 UNIX系统采用树状目录结构，具有良好的安全性，保密性和可维护性。 UNIX系统采用进程对换（Swapping）的内存管理机制和请求调页的存储方式，实现了虚拟内存管理，大大提高了内存的使用效率。 UNIX系统提供多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信。 Linux的特点 免费/开源 支持多进程/多用户 Linux系统同时可以支持多个用户，每个用户对自己的文件设备有特殊的权利，能够保证各用户之间互不干扰，就像手机开了助手一样，同时登陆多个qq账号，当硬件配置非常高时，每个用户还可以同时执行多个任务、多个线程同时工作、提高效率，简直是完美的一塌糊涂，单凭多用户而言就完爆其他操作系统。 安全性好 对内存和文件管理优越 由于Linux要保证其稳定性，所以并没有像其它操作系统一样内核如此臃肿庞大、漏洞百出，随着Linux内核的不断更新，不断提升着优势，Linux操作系统能把服务器的硬件优势体现的淋漓尽致，因为Linux系统吸取了Unix系统近1/4世纪发展的经验，最主要的是Linux开放源代码，保证系统稳定性，更好的调用硬件功能，同时还提供了丰富的系统资源工具top，freee，df，vmstat，dmesg，iostat，sar，uptime等，方便查看资源的利用率。 稳定性/高效性 你也许会听到Windows服务器长时间运行而突然宕机，但你绝不会听到Linux系统服务器因为长时间不关机会卡死，在Linux上几乎是不会出现这种情况的。Linux服务器可以无休止的运行下去不宕机，因为它继承了Unix卓越的稳定性和高效性。正因为它的稳定才获得了众多用户的青睐，因为它的高效，它的使用范围更加广阔，然而Linux还可以提供一些高可靠性的服务，比如:LNMP、虚拟化、数据库服务等等。 Linux是用来干嘛的?Linux最主要的用途肯定是用在做服务器 引用一句话：『你来是因为产品，你留下是因为生态系统』Linux 作为服务器的优势是，他目前具有最好的生态系统，服务器端的各种软件都为它而设计，默认都认为你是在 Linux 上跑，你要是整一个非 Linux 的服务器，你得有足够的心理准备，因为出现任何问题，你可能未必能找到能帮你解决问题的人。 作者：pansz链接：https://www.zhihu.com/question/19738282/answer/15530861来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 参考： 为什么程序员都喜欢Linux操作系统？ Linux 作为服务器操作系统的优势是什么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 事件]]></title>
      <url>%2F2017%2F08%2F09%2FJavaScript-%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[关键词 事件流 事件冒泡 事件捕获 事件委托 事件处理函数被执行的时机 自定义事件 事件触发的三个阶段 事件对象 事件目标元素 什么是事件流？什么是IE事件流？IE事件流和DOM事件流的区别是什么？事件流描述的是从页面中接收到事件的顺序，IE的事件流是事件冒泡（event bubbling）,而Netscape提出和支持的是事件捕获流，但由于Netscape已经被淘汰了，所以没有只支持事件捕获的浏览器了，而DOM 2级事件模型是把两种事件合并起来了。 DOM事件流的目的旨在通过事件捕获为截获事件提供了机会，通过事件冒泡设置处理程序响应事件。 #事件触发的三个阶段 1.document 往事件触发地点，捕获前进，遇到相同注册事件立即触发执行 2.到达事件位置，触发事件 3.事件触发地点往 document 方向，冒泡前进，遇到相同注册事件立即触发 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; document.getElementById('parent').onclick = function() &#123; alert('father emit!'); &#125; document.getElementById('child').onclick = function() &#123; alert('child emit!'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从上个例子的结果child emit！father emit！可以看出，通过onload注册的事件仅仅支持冒泡，也就是说通过DOM 0级的注册的事件处理程序仅仅只是在冒泡阶段被处理。 假如一个元素既注册了冒泡，也注册了捕获，是捕获先被触发呢还是冒泡先被触发呢？根据DOM2级事件流，捕获——到达——冒泡的顺序，应该是先发生捕获，再发生冒泡。 测试结果： 点击父元素，父元素捕获——父元素冒泡，符合先捕获后冒泡的事件流机制。 点击子元素，父元素捕获——子元素冒泡——子元素捕获——父元素冒泡，这里可以发现一个很重要的点，即当一个元素同时存在捕获和冒泡时，会按照注册的时候响应事件处理程序 如果是通过DOM 0级注册的冒泡，通过DOM2级注册的捕获在同一元素上，以上的结论还成立吗？还是先捕获再冒泡？ 结论还是按照注册的顺序响应事件处理程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 父元素按照先捕获后冒泡的方式注册 document.getElementById('parent').addEventListener('click',function() &#123; alert('parent event capturing emit!'); &#125;,true); document.getElementById('parent').addEventListener('click',function() &#123; alert('parent event bubbling emit!'); &#125;,false); // 子元素按照先冒泡后捕获的方式注册 document.getElementById('child').addEventListener('click',function() &#123; alert('child event bubbling emit!'); &#125;,false); // document.getElementById('child').onclick = function() &#123; // alert('child event bubbling emit!'); // &#125; [3] document.getElementById('child').addEventListener('click',function() &#123; alert('child event capturing emit!'); &#125;,true); &lt;/script&gt;&lt;/body&gt; 对事件流和事件处理程序的理解个人认为事件流在DOM2级以后，就是一种事件发生时，事件在DOM中逐级传播的正常现象，这种现象不由我们控制，而我们能做的只是决定我们需要在什么阶段响应事件。是冒泡阶段or捕获阶段？ 这个由我们来决定。 事件处理程序则是响应事件发生做点什么，事件处理程序被调用依赖于两个条件：事件传播到了注册的元素上且在指定的阶段。 举例，假如一个事件同时存在事件捕获和事件冒泡，事件捕获先注册，事件冒泡后注册，那么如果在事件捕获时通过调用e.stopPropagation()阻止事件的进一步传播，那是不是意味着冒泡阶段的事件处理程序不会再被调用？ 注意，这里e.stopPropagation()不会取消自身注册的冒泡阶段的事件处理程序响应！！！会触发；而想要在自身同时存在冒泡和捕获的时候取消第二次事件处理程序响应，需要通过e.stopImmediatePropagation()阻止任何事件处理程序被调用。（这也是这2个API的区别） 为什么我们通常在冒泡阶段调用处理程序？ 因为在跨浏览器的事件处理程序中，因为IE只支持冒泡，为了保证事件处理代码在大多数浏览器下一致性的运行的目的。所以事件处理程序被调用的时机也就只关注 冒泡阶段了。 事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。这里可能存在疑问：我们把事件处理程序挂在父级元素上，如何在处理程序中去操作子元素？ 一般挂在子元素中，我们明确知道this指向的就是子元素，即操作我们的目标元素，那么在父元素中如何操作子元素呢？不得不提的e.target 属性,这个属性会返回事件触发的目标元素，注意这个目标元素一定是唯一的！举例来说：document，parent，child，点击了parent区域就一定是parent，点击了child区域就一定是child，而不会像事件流那样的既是child，也是parent！！！ 注意：这里再次说明了事件流不是毫无目的 的“随意流”，而是流到事件的目标元素。 123456789101112131415161718192021222324252627282930313233343536e.target 类型 Element&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: blue &#125; #child &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 把事件处理挂在父元素上， parent.addEventListener('click',function(e) &#123; alert(e.target.id); let _this = e.target; // 获取到目标元素，也就是事件实际的目标 &#125;,false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情，就像老板一下命令，各自员工做自己岗位上的工作去了。之前分别给parent，child注册的click事件，就是同一事件各自响应各自的处理程序。 事件冒泡的意义以及应用事件委托：只指定一个事件处理程序，就可以管理某一类型的所有事件。 原理：利用事件冒泡机制，给父元素绑定事件处理程序并指定事件处理程序的响应阶段为冒泡阶段，这个时候点击子元素，由于子元素没有事件处理程序，所有没有任何反应，但是事件流会继续向上冒泡，也就是冒泡到父元素，父元素有处理程序，并且父元素可以知道实际上事件发生时的目标元素——通过e.target =&gt; 这个是核心 核心： 通过e.target可以确定实际触发的目标元素 好处：前者少了一个遍历所有li节点的操作，所以在性能上肯定是更优的；其次当我们绑定完事件以后又动态添加了一些元素，这时候如果是给每个子元素绑定事件，那么为了效果，我们还要为新添加的子元素绑定一次事件，重复操作且代码冗余。 event对象为什么这么重要呢？因为event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样（原生事件直接封装好）。 关于currentTarget和target属性对象this始终等于currentTarget的值，而target的值只包含事件的实际目标。（触发事件的实际目标） 如果直接将事件处理程序指定给目标元素，则this，currentTarget，target包含相同的值。差异体现在冒泡上。 自定义事件和DOM中的事件模拟DOM中的事件模拟1234567891011121314151617181920// step1:创建event对象var event = document.createEvent(&#123;string&#125;) // 该方法创建一个event对象，该方法接收一个参数，表示创建的事件类型的字符串（指定好的），所以字符串在DOM2级中使用复数形式，而在DOM3级中使用了单数形式，这也是为什么有s和没s没区别的原因。// step2:初始化事件event.initEvent(eventName, canBubble, preventDefault) // 分别表示事件名称，是否可以冒泡，是否阻止事件的默认操作。 // step3:设置事件发生时的参数event.target = this;event.message = 'sr';...根据不同的实际需求设置// step4: 绑定到DOM元素上，此时这个事件就跻身“官方事件”$(dom).addEvent(eventName,function() &#123; alert('hahahaha')!&#125;, false);// step5: 触发事件$(dom)dispatchEvent(event) // 所有支持事件的DOM节点都支持这个方法。调用dispatchEvent（）方法时，需要传入一个参数，即表示要触发事件的event对象。 所以综上：DOM中的事件模拟，包括 创建一个指定类型的事件实例 初始化事件：事件名称，是否冒泡，是否阻止事件的默认行为 设置事件对象的属性（模拟那些已有的，可以在事件处理程序中通过传参获得） 注册事件 触发事件 如何理解触发事件？对于dispatchEvent触发的理解——任何点击、各种交互其实都只是形式，形式内在也是封装了dispatch（）罢了 为什么要模拟DOM事件？大部分事件本身是由用户交互来触发的，但是有些时候我们想让程序自己来触发事件，这个时候就需要手动调用函数来实现触发事件，并传入参数event，作为当这个事件触发时传递出去的信息。 有什么用?这个触发事件的机制由我们自己来决定了，我们可以设置自己的条件逻辑 eg： 123if(...) &#123; Element.dispatchEvent(e)&#125; 然后对这个事件有监听的DOM元素就会被监听到，此时事件处理程序响应。 补充如果是模拟一些比较复杂的DOM事件，比如鼠标事件，官方提供了很多事件对象的属性，用于在模拟的鼠标事件发生时传递一些信息：包括元素相对于屏幕，视口的坐标等… 自定义事件 自定义事件的本质：观察者模式 基于原生事件，触发依赖于原生事件的触发机制 自定义事件没有浏览器帮你，需要自行设置触发 为什么要有自定义事件？站在一个更高的层次上进行封装和对客观世界的描述，比如我们会说 点击盒子触发xx事件，而不会说点击某个div，btn这样的DOM节点 优点：跳出原生事件的限制，提高了封装的抽象层级 对比原生事件：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 historyAPI]]></title>
      <url>%2F2017%2F08%2F08%2FHTML5-historyAPI%2F</url>
      <content type="text"><![CDATA[源起学习webpack使用的时候，写简单SPA应用时需要通过pushState API变更历史URL，并加载页面 是什么？访问历史记录 123456789101112131415/* * description: 向历史记录里添加一条历史记录，此时地址栏发生变化，历史记录里添加了一条状态，但是页面并不会刷新也不会跳转，！！！注意此时新增的状态为当前通过pushState添加的，而历史记录里的是之前的状态被压栈 * summary: 存储当前状态 * @param: &#123;Object&#125; state state为一个对象或者null，称为状态对象。这个对象可以拿来记录当前URL所对应的一些信息，状态对象由pushState创建，在popstate事件触发的时候通过e.state拿到，总而言之，它存储JSON字符串，可以用在popstate事件中。 * @param &#123;String&#125; title title为页面的标题，但当前所有浏览器都忽略这个参数，传递一个空字符串是安全的做法。当然，你可以传递一个短标题给你要转变成的状态。 * @url &#123;String&#125; url url则为新历史记录的地址，不写则为当前页，请注意，浏览器在调用pushState()方法后不会去加载这个URL，并且这个地址和当前页必须是同源的 */history.pushState(state, title, url)// 参数同上history.replaceState(state, title, url)相关事件：popstate何时触发？当历史记录条目发生更改时，注意这个更改指的是点击了浏览器历史记录的前进/后退或者是调用history.back()/history.go()/history.forward()时。需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。而popstate事件的state属性就是历史状态对象的副本。 有什么用？界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态，在HTML5可以通过window.history操作访问历史状态，让一个页面可以有多个历史。 为什么会有？假设一个学生管理系统的记录的页面，然后我们需要把这个页面学生违纪的内容发送给他人，但是如果仅仅只是一个tab栏切换，我们发送URL地址就会有一个尴尬的现象，就是发过去的又是初始化的页面（也就可以理解为：无状态），因为URL地址至始至终没有发生变化过。 简单来说就是动态加载出来的内容我们无法给别人分享链接。这种对状态的需求在应用开发中尤为迫切！！！ 因为AJAX的兴起，前端走向了web应用的时代，利用AJAX动态加载实现内容替换。但是弊端是利用AJAX实现无刷新改变的文档内容，是不会修改URL的，但是这里有人要问为什么一定要修改URL呢？因为一个URL代表一个特定的网络资源，AJAX修改了页面的内容，所以用不同的URL去标识他们，这个是非常有必要的。 这种状态思想特别是在现在web开发（web应用）中是非常重要的。 以前的history有什么？之前我们可以通过history对象实现前进，后退，和刷新之类的操作 1234history.length; // 历史堆栈中的记录数history.back(); // 后退history.forward(); // 前进history.go([delta])：delta是个数字，如果不写或为0，则刷新本页；如果为正数，则前进到相应数目的页面；若为负数，则后退到相应数目的页面。 demo1—基本用法和效果12345678910 window.onpopstate = function(event) &#123; alert("location: " + document.location + ", state: " + JSON.stringify(event.state));&#125;;history.pushState(&#123;page: 1&#125;, "title 1", "?page=1"); // 添加一条状态，此时地址栏变为url+"?page=1"，之前的入口页被压入历史记录history.pushState(&#123;page: 2&#125;, "title 2", "?page=2"); // 添加第二条状态，此时上一个状态被添加到历史记录，此时历史记录里应该有两个状态// history.replaceState(&#123;page: 3&#125;, "title 3", "?page=3");history.replaceState(&#123;page: 3&#125;, "title 3", "http://www.baidu.com"); // [1] 替换当前状态信息，此时因为没有添加，所以历史记录里还是两条状态信息// history.back(); // [2] alerts "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;" 通过结果可以看出replaceState只是替换了当前状态而不是替换当前，追加之前到历史栏// history.back(); // [3] alerts "location: http://example.com/example.html, state: null 通过结果可以看出当第二次回退，实际上回到了最初的入口页，这个状态在页面载入，脚本执行后就被放入了历史记录里// history.go(2); // [4] alerts "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125; 通过结果可以看出page2确实被page3替换掉了 对pushState的误解 一开始误认为pushState会直接向地址栏加入我们通过调用pushState()添加的状态，而pushState()其实是改变了当前状态，把当前状态前一个状态添加到历史记录。 源自张鑫旭老师的historyAPI demo配合ajax技术实现的PJAX技术 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152JS代码：// 获取元素，绑定事件，获取查询参数var eleMenus = $("#choMenu a").bind("click", function(event) &#123; var query = this.href.split("?")[1]; if (history.pushState &amp;&amp; query &amp;&amp; !$(this).hasClass(clMenuOn)) &#123; /* ajax载入~~ */ // history处理 var title = "上海3月开盘项目汇总-" + $(this).text().replace(/\d+$/, ""); document.title = title; if (event &amp;&amp; /\d/.test(event.button)) &#123; history.pushState(&#123; title: title &#125;, title, location.href.split("?")[0] + "?" + query); &#125; &#125; return false;&#125;);//var fnHashTrigger = function(target) &#123; var query = location.href.split("?")[1], eleTarget = target || null; if (typeof query == "undefined") &#123; if (eleTarget = eleMenus.get(0)) &#123; // 如果没有查询字符，则使用第一个导航元素的查询字符内容 history.replaceState(null, document.title, location.href.split("#")[0] + "?" + eleTarget.href.split("?")[1]) + location.hash; fnHashTrigger(eleTarget); &#125; &#125; else &#123; eleMenus.each(function() &#123; if (eleTarget === null &amp;&amp; this.href.split("?")[1] === query) &#123; eleTarget = this; &#125; &#125;); if (!eleTarget) &#123; // 如果查询序列没有对应的导航菜单，去除查询然后执行回调 history.replaceState(null, document.title, location.href.split("?")[0]); fnHashTrigger(); &#125; else &#123; $(eleTarget).trigger("click"); &#125; &#125; &#125;;if (history.pushState) &#123; window.addEventListener("popstate", function() &#123; fnHashTrigger(); &#125;); // 默认载入 fnHashTrigger();&#125; 使用pushState实现有状态的tab栏切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;History Api&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; overflow: hidden; margin: 0; padding: 0; &#125; aside &#123; background-color: #ccc; width: 220px; float: left; height: 100%; &#125; aside ul &#123; font-size: 20px; line-height: 2; &#125; aside ul li &#123; cursor: pointer; &#125; article &#123; background-color: #f5f5f5; margin-left: 220px; padding: 20px; height: 100%; overflow: scroll; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;aside&gt; &lt;ul id="list" data-id="1" data-name="sss"&gt; &lt;/ul&gt; &lt;/aside&gt; &lt;article&gt; &lt;p id="content"&gt;&lt;/p&gt; &lt;/article&gt; &lt;!-- plugin:auto file name --&gt; &lt;script src="data.js"&gt;&lt;/script&gt; &lt;script&gt; (function() &#123; var listElement = document.querySelector('#list'); // 遍历数据并渲染到页面 for (var title in data) &#123; var liElement = document.createElement('li'); liElement.innerHTML = '⭐️' + title; liElement.setAttribute('data-title', title); listElement.appendChild(liElement); &#125; var liElements = document.querySelectorAll('#list&gt;li'); var content = document.querySelector('#content'); // 注册每一个元素事件，点击时保存当前状态 for (var i = 0; i &lt; liElements.length; i++) &#123; liElements[i].addEventListener('click', function() &#123; // 拿到被点击title var title = this.dataset['title']; // 赋值 content.innerHTML = data[title]; // 操作历史记录 if (window.history &amp;&amp; history.pushState) &#123; // 添加一个新的历史记录 history.pushState(title, 'title没有任何浏览器支持', '?t=' + title); &#125; else &#123; console.log('不支持'); &#125; &#125;); // 当我们在伪造的访问历史中前进或后退时会执行一个popstate事件 window.addEventListener('popstate', function(e) &#123; // 回退时根据保存的状态渲染页面内容 content.innerHTML = data[e.state]; &#125;); // window.location = "https://www.baidu.com"; // 第一次请求过来 获取地址栏中的t参数 // window.location可以拿到当前网页中跟地址相关的信息 var search = window.location.search; // ?t=jkaljdksfla // 如果地址栏中的地址有中文，会以URL编码方式呈现 // decodeURI 可以转换到之前中文 var title = search.split('=')[1]; // ['?t','jkaljdksfla'] if (title) &#123; // 有值 decodeURI作用就是从URL编码转换到之前的状态 console.log(decodeURI(title)); content.innerHTML = data[decodeURI(title)]; &#125; &#125;)(); &lt;/script&gt; 此例子最大的效果在于：保存了状态，当把URL发送给别人的时候，得到的是一个带有状态的视图，而不是初始化页面。 参考： popstate·MDN ajax与HTML5 history pushState/replaceState实例·张鑫旭 PJAX的实现与应用·小胡哥]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解JavaScript作用域]]></title>
      <url>%2F2017%2F05%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[关键词 作用域 定义时 变量查找规则 赋值操作基于作用域查找规则 查找目标的值也是基于作用域查找规则 作用域规则JavaScript作用域是定义时的概念，用于确定在何处以及如何查找变量（标识符），如果是对变量的赋值操作就会进行LHS查询，如果是获取变量的值就会进行RHS查询。 深入理解”定义时”概念两个函数唯一的区别：在于函数体内部的变量x是否用var重新声明. 当使用默认参数的时候，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失。 12345678910111213141516171819例1：var x = 1;function foo(x, y = function() &#123; x = 2&#125;) &#123; var x = 3; y(); console.log(x);&#125;foo(); // 3x; // 1----------------------------------------------例2：var x = 1;function foo(x, y = function() &#123; x = 2&#125;) &#123; x = 3; y(); console.log(x);&#125;foo(); // 2x; // 1 代码的执行过程：参数初始化过程和函数体代码执行过程 对于例1很容易得出错误的结果foo(); // 3 x; // 1 错误的原因就是：对于作用域是定义时概念理解得不深刻。 123456789101112参数初始化过程：1.形成一个独立的作用域，当不传递参数y时，使用默认参数值进行初始化&#123; let x; let y = function() &#123;x = 2 &#125;;&#125;2.代码执行的过程var x = 3; // 用var重新声明了和参数同名的变量x，则此时参数x被覆盖，变量x和参数x不是同一个xy(); // 函数调用，对变量x进行赋值操作，这时最容易出错的地方 // 因为y函数内部并没有变量x，则对外层的变量x进行赋值，关键是对哪一个外层的x进行赋值？ // 这里很容易理解成调用时函数y的外部x进行赋值，这个时候就把定义时的概念没有理解清楚。 // 而真实的是此时对参数作用域中的x进行赋值，但因为参数x和变量x不指向同一个x，而函数体内使用的是变量x，所以赋值操作没有生效。 对于例2,因为没有用var重新声明一个同名变量，此时函数体内的x指向参数x，y赋值操作的目标也是参数x，两个x是同一个x，所以y()赋值成功。 关于为什么会错误理解因为时常弄混淆静态作用域和动态this 动态作用域JavaScript中的作用域是词法作用域 词法作用域是一套关于引擎寻找变量以及会在何处找到变量的规则。词法作用域最最最最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval()或with） 动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式。 123456789101112function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2. 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。动态作用域的查找结果导致a为3. 简单总结区别 词法作用域是在写代码的时候或者说定义时确定的，而动态作用域是在运行时确定的，（this也是！） 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript函数的设计]]></title>
      <url>%2F2017%2F05%2F18%2FJavaScript%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[关键词 黑匣子 抽象 封装 参数个数检查 参数类型检查 函数的核心理念——抽象和封装过程封装过程：指的是用户只需知道函数名，如何正确的传递参数以及返回值就够了，而内部的逻辑用户无需知道。 抽象：借助抽象，我们才能不关心底层具体的实现/计算过程，而直接在更高层上思考问题。 而函数就是抽象的方式，一个函数就是一个一个完整的行为，函数体内部的语句在执行的时候，函数内部通过条件判断和循环就可以完成非常复杂的逻辑。 函数的执行过程输入（传参）——计算/处理 ——输出（返回结果，如果有） 函数就是一段完整的代码，函数在执行的过程中，如果没有return语句（函数结尾如果没有return语句就是隐含 return undefined）,控制权无法交回被调用的代码。一旦执行到return时，函数就执行完毕，并将结果返回。 ES6中的Generator函数除外，Generator函数的yield类似return，可以返还控制权。 JS中的函数 JavaScript中函数定义参数时没有指定参数的数据类型 JavaScript中的函数不会对参数arguments进行类型检查 JavaScript中的函数不会对arguments进行个数检查 JavaScript中函数没有重载 对比JAVA的函数123public String getRecord(int key) &#123; return db[key]; 修饰符public修饰了函数getRecord的可访问性 String说明了存在返回值并且说明了返回值类型 int key说明了参数类型和参数名字 JAVA函数的定义1、支持重载 2、定义函数时就可以看到函数的访问性（访问控制修饰符） 3、定义函数时就可以看到函数的返回值类型 4、定义函数时就可以看到函数的参数类型 对比Python函数调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt;abs(1, 2)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' Python函数调用1、拥有对参数个数检查的机制 2、拥有对参数类型检查的机制 集百家所长编写健壮的JS函数因为js函数没有对实参进行检查的机制,所以我们编写函数就要自己模拟实现这些机制 从Python中得到的感悟首先，对参数的个数进行检查 利用arguments参数判断实际传入参数的个数,这也就是说即使函数没有定义参数，也可以拿到参数的值，也是很多js库常使用的手段 实现：可选”参数” 123456// 接收2-3个参数，参数b是可选参数，如果只传2个值，b默认为nullfunction abc(a, b, c) &#123; if(arguments.length === 2) &#123; //实际拿到的是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 其次，检查参数的数据类型 使用条件判断的方式判断参数的是否传递，以及参数是否是期望的值 12345678910function log(x, y) &#123; if(typeof y !== 'string') &#123; //检测参数的数据类型 y = 'World'; &#125;&#125; console.log(x, y);log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 从JAVA中得到的感悟JAVA中的函数从函数的定义就可以看到函数的参数类型，是否有返回值和返回值类型 所以为了编写可维护的JavaScript函数，我们可以利用注释和规范的命名实现对函数的描述。 利用函数名描述函数的功能 利用参数名描述参数是什么，利用注释描述参数的数据类型 利用返回值描述结果是什么，利用注释描述返回值的数据类型 或者写一段完整注释包括：描述函数的目的，功能，参数和参数类型，返回值和返回值类型 模拟函数重载函数重载：函数名相同，参数的个数和类型不同，实现不同的功能。 模拟重载：利用条件判断判断参数的个数和参数的类型，来实现重载。 参考： 廖雪峰·Python教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包中使用this存在的问题]]></title>
      <url>%2F2017%2F05%2F16%2F%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8this%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[关键词 闭包 函数声明时 函数运行时 词法作用域 特殊变量 箭头函数 前言也是为什么老是有var that = this;的写法以及箭头函数产生的原因。 闭包中使用this的问题在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。 12345678910111213//在闭包中使用this是想和利用闭包的特性像引用其他其他变量一样引用保存外层函数的this，但是期望与现实是相反的。// 因为this是一个运行时基于函数的调用环境绑定的特殊变量。特别是，匿名函数的执行环境具有全局性。var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; return function() &#123; //闭包 return this.name; //在闭包中使用this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 Window 为什么this会指向undefined呢？这是因为每个函数在调用的时候都会自动取得两个特殊的变量，this和arguments，内部函数在搜索这2个变量的时候，只会搜索到其活动对象为止，因此永远不可能访问到外部函数中的这2个变量。 那么如何访问到这两个变量呢？把外部作用域中的this保存到一个闭包能访问到的变量里，并在闭包中引用那个变量，而不是引用this常见的 12var this = that;var args = Array.prototype.slice.call(arguments); 上例的修改后： 12345678910111213var name = 'The Window';var object = &#123; name: 'My Object', getNameFunc: function() &#123; var that = this; //修改：保存外部作用域的this到一个闭包能访问到变量中 return function() &#123; //闭包 //return this.name; //在闭包中使用this return that.name; //修改：在闭包中通过引用that来引用外部作用域的特殊变量this &#125; &#125;&#125;;console.log(object.getNameFunc()()); //在严格模式中 undefined //在非严格模式下浏览器中 this指向Window ES6的箭头函数：ES6的箭头函数最佳的使用姿势就是解决this指向问题。因为在JavaScript中，对象之间的调用是非常繁杂的，一不小心遇到this被篡改的问题，导致后面的代码出错： 比如 1234567891011121314class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(function() &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); //undefined says hi 这是一个比较经典的this被篡改的问题，因为这个setTimeout函数，他的this指向window对象。 我们可以利用一个变量保存住这个this指针，也或者使用bind(this)方法，但有了箭头函数，等于函数本身集成了保存this指针的功能，这让我们不是处处提防this陷阱。同样的，基于这个原因，箭头函数中没有自己的this，但当你在箭头函数内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的 this。 箭头函数最常用于回调函数，如事件处理器或定时器中12345678910111213141516171819202122232425262728class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; setTimeout(() =&gt; &#123; console.log(this.type + ’says’ + say); &#125;, 1000); &#125;&#125;let animal = new Animal();animal.says(‘hi’); // animal says hi//等价于class Animal &#123; constructor() &#123; this.type = ‘animal’; &#125; says(say)&#123; var that = this; setTimeout(function() &#123; console.log(that.type + ’says’ + say); &#125;, 1000); &#125;&#125; 对箭头函数的误解 最大的误解：箭头函数使用的是外部函数（这里理解成父函数）的this 是否局部（Lexical）？12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;,100);&#125;foo.call( &#123; id: 42 &#125; );// id: 42 这里的 =&gt; 箭头函数看起来把它内部的this绑定为父函数 foo() 里的 this。如果这个内部函数是一个常规的函数（声明或表达式），它的 this将类似 setTimeout如何调用函数一样被控制着。 但是实际上是箭头函数内部根本没有this变量，对于this变量的访问变量就像根据词法作用域查找一般变量一样,查找到有this变量的外层作用域，而不是父级作用域。 箭头函数的注意1）箭头函数 =&gt; 所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去”, 虽然 =&gt; 箭头函数没有一个自己的 this，但当你在内部使用了this，常规的局部作用域准则就起作用了，它会指向最近一层作用域内的this。 123456789101112function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&quot;id:&quot;, this.id); &#125;; &#125;; &#125;;&#125;foo.call( &#123; id: 42 &#125; )()()();// id: 42 有多少次 this 的绑定执行了呢？大部分人会认为有4次——每个函数里各一次。 事实上更准确地说，只有一次才对，它发生于 foo() 函数中。 这些接连内嵌的函数们都没有声明它们自己的 this，所以 this.id 的引用会简单地顺着作用域链查找，一直查到 foo() 函数，它是第一处能找到一个确切存在的 this 的地方。 说白了跟其它局部变量的常规处理是一致的！ 换句话说，正如同 Dave 说的一样，this 生来局部，而且一直都保持局部态。=&gt;箭头函数并不会绑定一个 this 变量，它的作用域会如同寻常所做的一样一层层地去往上查找。 2)不仅仅是this 如果你贸贸然地同意了“箭头函数就是常规function的语法糖”这样的观点，那是不正确的，因为事实并非如此——箭头函数里并不按常规支持 var self = this 或者 .bind(this) 这样的糖果。 那些错误的解释都是典型的“给对了答案却讲错了原因”，就像你在高中代数课的测试上明明写对了答案，但老师仍会画圈圈告诉你用错方法了——如何解得答案才是最重要的！ 另外，关于“=&gt;箭头函数不绑定自身的 this，而允许局部作用域的方案来沿袭处理之”的正确描述，也解释了箭头函数的另一个情况——它们在函数内部不走寻常路的孩子不仅仅是 this。 事实上 =&gt;箭头函数并不绑定 this，arguments，super(ES6)，抑或 new.target(ES6)。 这是真的，对于上述的四个（未来可能有更多）地方，箭头函数不会绑定那些局部变量，所有涉及它们的引用，都会沿袭向上查找外层作用域链的方案来处理。 12345678function foo() &#123; setTimeout( () =&gt; &#123; console.log("args:", arguments); &#125;,100);&#125;foo( 2, 4, 6, 8 );// args: [2, 4, 6, 8] 这段代码中，=&gt;箭头函数并没有绑定 arguments，所以它会以 foo() 的 arguments 来取而代之，而 super 和 new.target 也是一样的情况。 3）this在箭头函数中被绑定，4种绑定规则中的无论哪种都无法改变其绑定 4）箭头函数不可以当作构造函数，也就是不可以使用new命令，否则会报错 最后虽然箭头函数可以把作用域和this机制联系起来，但是却容易混淆，使代码难以维护。应该在作用域和this机制中二选一，否则就会造成混淆。要么只使用词法作用域，要么只使用this机制，必要时使用bind()。尽量避免使用that=this和箭头函数共同使用。 参考： ES6 箭头函数中的 this？你可能想多了（翻译） ECMAScript 6 入门-箭头函数 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解JavaScript中对象内容的访问方式]]></title>
      <url>%2F2017%2F05%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[整理一下对象访问两种方式的区别以及持续更新不同的使用场景 对象内容的访问的两种方式： . 操作符：通常称为“属性访问” [ ] 操作符：通常称为“键访问” 属性访问和键访问的异同相同实际上它们访问的是同一个位置，并且会返回相同的值 区别 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。 . 操作符后面总是字符串，所以为对象增加属性的时候使用点语法，会自动把属性名称转为字符串， 举例： 1.如果要引用名称为 “Super- Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效 的标识符属性名。 2.使用Symbol值作为对象的属性名时只能使用 [ ] 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 123456789101112131415161718var mySymbol = Symbol();//第一种写法var o = &#123;&#125;;o.mySymbol = 'Hello';//第二种写法var o = &#123;&#125;;o[mySymbol] = 'Hello';//第三种写法var o = &#123; [mySymbol]: 'Hello!'&#125;;// 第四种写法var o = &#123;&#125;;Object.defineProperty(o, mySymbol, &#123; value: 'Hello!' &#125;); 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意：第一种写法是不会读取mySymbol作为标识符所指代的那个值的，因为点语法后面总是字符串，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 123o.mySymbol = 'Hello!';o[mySymbol] // undefinedo['mySymbol'] // "Hello!" 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 [ ] 使用场景1.可计算属性名 2.Symbol值作属性名 3.需要使用变量方式遍历属性 4.函数传参，参数作属性名，或者属性名的一部分，只能使用 [ ] 5.使用对象法进行数组去重，对象的键是一个变量 参考：ECMAScript6 入门——Symbol]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运算符]]></title>
      <url>%2F2017%2F05%2F10%2FJavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[关键词 表达式 优先级 结合性 执行顺序 求值顺序 JavaScript运算符 也叫操作符，英文：operator，关于运算符，除了都知道的优先级，还要知道Associativity JavaScript中的运算符大多由标点符号表示，少数由关键字表示，每一个运算符具有不同的行为，运算符始终都遵循着一些固定语法。一些运算符可以作用于任何数据类型， 但仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回一个特定类型的值，在下面的运算符规则表中，箭头前为运算符操作数的类型，箭头后为运算结果的类型 分类 JavaScript的运算符总共有59个，如果根据其操作数的个数进行分类，分为一元运算符，二元运算符，三元运算符。而它们的目的都是一致的: 将一个到多个表达式合并为一个表达式 优先级和结合性 运算符优先级控制着运算符的执行顺序，优先级高的运算符的执行总是先于优先级运算符低的运算符——————错误的理解 修正：不同操作相邻出现的时候，表达式是作为左操作符的后操作数呢？还是作为右操作符的前操作数呢？=&gt;这就是操作符优先级干的事 对优先级错误的理解： 认为拿到一行语句，先按照操作符的优先级划分，找到最高优先级的操作符，先求值。 所以就对 baz&amp;&amp; fn()这样的代码存在困惑，因为如果这么理解的话，fn()的优先级最高，那么无论如何都会先执行 fn()再去 &amp;&amp; 判断，可实际的是 &amp;&amp;判断前面的baz是否存在而决定是否执行后面的fn()，此时发生冲突。但实际上所谓的优先级是指操作数结合操作符，优先结合。即同一个操作数被左右两个操作符共同使用的时候，此时这个操作数并不会被两个操作符共同使用，而决定它被谁使用的依据就是操作符的优先级。不是说谁的优先级高就先给谁求值。 简单一点的说，所谓的优先级就是加个括号,而优先级和结合性就是决定括号怎么加 那么何时求值？比如 d = a + (b+c) 对表达式d求值，首先对表达式a求值，返回；然后要对 + 后的一个表达式求值，此时 + 后面的表达式结果依赖于b + c，此时b + c才开始求值，因为最终的结果依赖b + c 的结果，所以才有了求值。 所以像短路运算符 &amp;&amp; 和 || 一起出现的时候，因为&amp;&amp;的优先级要比||高，所以&amp;&amp;优先结合操作数（但是并不意味着要立即求值，还是要根据从左往右的顺序，先对第一个操作数求值。剩下的，有依赖有需求才会求值。） 所以千万不要再理解成优先级高，优先求值 优先级是怎么产生的？1234567891011121314例1：var a =42, b;b = (a++, a);a; //43b; //43如果去掉括号会怎么样？var a=42, b;b = a++, a;a; //43b; //42 【1】注意： b的结果不一样了，上面代码发生了什么？说明了什么？ 原因就在于,运算符的优先级比=低,当不同操作相邻（, =）出现时，表达式a++是作为=的后操作数呢？还是作为,的前操作数呢？ =&gt;操作符的优先级工作了 =&gt;因为=&gt;的优先级高于, =&gt;原式&lt;=&gt;(b = a++), a; =&gt;此时a++后自增，先返回值，所以表达式b的值是42 1234简单的例2：fn01() || fn02 &amp;&amp; fn03();//等价于fn01() || (fn02 &amp;&amp; fn03()); // &amp;&amp; 优先级高于 || fn02结合&amp;&amp; 1234567891011121314151617181920212223242526例3：var d = a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a;分析：1.先解决优先级问题=&gt;哪里发生了优先级问题？ a b c c b c b a (看操作数两边的符号，除了第一个操作数和最后一个操作数以及三元表达式 ? a :都会发生优先级问题)2.再来一遍，a发生优先级问题，看表达式a的左边和右边，&amp;&amp; 高于 = =&gt; a 作为&amp;&amp;的前操作数3.再看表达式b，b发生优先级问题，看表达式b的左边和右边,&amp;&amp; 高于 ||=&gt; b 作为&amp;&amp;的后操作数=&gt;var d = (a &amp;&amp; b) || c ? c || b ? a : c &amp;&amp; b : a;//...重复以上步骤，得出以下结果=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;做到这一步无法往下做了，可以看成e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;此时仅有优先级已经无法满足求值的需求了。--------------- ---------------- Associativity（结合性） 如果所有操作符优先级一样，结合性决定了执行结果的唯一性。 结合性是怎么起作用的？当表达式相邻的操作符具有相同的优先级时，优先级已经不能决定表达式最终结果的时候，结合性就起作用了。 12345678910111213141516171819202122回到之前例子没有解决的问题：=&gt;var d = ((a &amp;&amp; b) || c) ? (c || b) ? a : (c &amp;&amp; b) : a;e = ((a &amp;&amp; b) || c)f = (c || b)g = (c &amp;&amp; b)=&gt; e ? f ? a : g : a;这里没有可能性二//可能一e ? (f ? a : g) : a; true --- a / true --- (f ? a : g) / \false --- ge \ false --- a 结合性解决了什么问题？ 当优先级一样的时候括号怎么加 1a OP b OP c 左结合性（从左到右）意味着它被处理为(a OP b) OP c，而右结合性（从右到左）意味着它被解释为a OP (b OP c)。而对于以下代码右结合性是正确的，所以你可以写： 1234567891011a = b = 5;分析：对于表达式b，左边和右边是相同的操作符，优先级一样的。所以优先级已经无法解决这种情况下的执行结果了。显然，如果只有优先级的话，a = b = 5; //可能性1(a = b) = 5;//可能性2a = (b = 5);但是由于(a = b) = 5中，(a = b)的结果并不是一个变量，而是一个返回表达式a赋值后的结果2，因此它不能出现在等号的左边！所以以上最终的执行结果只有可能是可能性2 那么： 12345678910111213141516171819202122232425262728293031323334a?b:c?d:e//可能性一(a?b:c)?d:e true --- d / true --- b / \ a false --- e true --- d / \false --- c \ false ---e =&gt; a 执行结果 d || e //可能性二（因为三元表达式右结合）a?b:(c?d:e) true --- b / a true --- d \ / false --- (c?d:e) \ false ---e =&gt; a 执行结果 b || d || e 结果不唯一了，所以结合性干的事就是确保结果的唯一性。 这个要怎么算？先看优先级，两个一样。再看结合性，右结合，所以：先算c?d:e再算 a?b:（c?d:e） 这就是所谓右结合。如果是左结合的话 就是先算a?b:c再算 （a?b:c）?d:e实际上，一般结合性的问题都可以用括号来解决。 先要考虑优先级，有相同优先级的就看结合性以决定括号的添加方式。结合性决定处理相同优先级的运算符的顺序 或者说为什么结合性不同影响着执行结果？？？ 因为表达式可能会产生副作用，比如函数调用: 1var a = foo() &amp;&amp; bar(); 这里foo()会首先执行，它的返回结果决定了bar()是否执行。所以如果bar(）在foo（）之前执行，整个结果完全不同。 如何更好理解操作符的结合性？？？ 想象一下，什么情况下 AB 不等于 BA 矩阵（不考虑单位矩阵的情况下） 执行顺序 执行顺序是不变的，总是从左到右。优先级和结合性并没有影响代码的执行顺序，也无法影响，它们做的是改变了表达式的求值顺序，注意 执行顺序 != 求值顺序 1234567891011121314151617181920var a=1;b=(a=3)+a++;这个例子中运算顺序是这样的1.计算b2.a＝33.a++(设为c)4.计算a（这时候a变成了4已经，不是再最后才变得，但表达式使用的是a++的结果c，也就是a原来的值）5.计算3+c6.把3+c赋值给b = / \ b + / \ = ++ / \ / a 3 a 深入浅出优先级，结合性，执行顺序，求值顺序 代码执行顺序是永远不变的，从左往右执行。 而优先级和结合性是如何添加括号的依据，表达式越先求值的说明离AST根节点越远，为什么？先求值的说明依赖少，有依赖的还得继续向下遍历。 什么是左值(Left-hand-side expressions) Left values are the destination of an assignment. 左值指的是赋值操作的目标，也就是能出现在赋值表达式左边的表达式，自定义的函数不能返回左值是ECMAScript的规范。 那么什么类型的值可以出现在赋值表达式的左侧呢？变量对象属性数组元素 运算符总结（持续更新） 优先级 运算符 操作 结合性 类型 20 ( … ) 分组 N/A N/A 19 … . … 成员访问 l-to-r 19 … [ … ] 成员访问 l-to-r N/A 19 new … ( … ) 有参构造 N/A N/A 18 … ( … ) 函数调用 l-to-r N/A 18 new … new.target操作符检测是否用new操作符调用函数/构造函数 r-to-l new.target=&gt;undefined/ 在类构造函数中，new.target指的是直接调用的构造函数new。 17 … ++ 后自增 N/A N/A 17 … – 后自减 N/A N/A 16 ! … 逻辑非 r-to-l bool-&gt;bool 16 ~ … 按位求反 r-to-l 16 + … 一元加(注意区别于二元加) r-to-l any=&gt;num 16 - … 一元减(注意区别于二元减) r-to-l any=&gt;num 16 ++ … 先自增 r-to-l 属于算术运算符，操作lval 16 – … 先自减 r-to-l 属于算术运算符，操作lval 16 typeof … 判断类型 r-to-l any=&gt;str 16 void … 返回空 r-to-l any=&gt;undefined 16 delete … 删除属性 r-to-l lval-&gt;bool 15 … … 幂运算 r-to-l any,any=&gt;num，求幂前会发生类型转换num 14 … * … 求积 l-to-r any,any=&gt;num，求积前会发生类型转换num 14 … / … 求商 l-to-r any,any=&gt;num，求商前会发生类型转换num 14 … % … 取余 l-to-r any,any=&gt;num，求商前会发生类型转换num 13 … + … 求和/拼接(考虑类型转换) l-to-r any,any=&gt;any 13 … - … 求差(考虑隐式转换） l-to-r any,any=&gt;num 12 … &lt;&lt; … 按位左移 l-to-r 12 … &gt;&gt; … 按位右移 l-to-r 12 … &gt;&gt;&gt; … 无符号右移 l-to-r 11 … &lt; … 小于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &lt;= … 小于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt; … 大于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … &gt;= … 大于等于(会发生隐式转换） l-to-r any,any=&gt;bool 11 … in … 测试属性 l-to-r str,obj=&gt;bool 11 … instanceof … 测试对象类(含原型链) l-to-r obj,fn=&gt;bool 10 … == … 测试相等 l-to-r any,any=&gt;bool 10 … != … 测试不等 l-to-r any,any=&gt;bool 10 … === … 测试严等 l-to-r any,any=&gt;bool 10 … !== … 测试严不等 l-to-r any,any=&gt;bool 9 … &amp; … 按位与 l-to-r 8 … ^ … 按位非 l-to-r 7 … | … 按位或 l-to-r 6 … &amp;&amp; … 逻辑与（操作数选择器） l-to-r any,any=&gt;any 5 … || … 逻辑或（操作数选择器） l-to-r any,any=&gt;any 4 … ? … : … 三元表达式 r-to-l bool,any,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … += … 运算且赋值 r-to-l lval,any=&gt;any 3 … -= … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … = … 运算且赋值 r-to-l lval,any=&gt;any 3 … /= … 运算且赋值 r-to-l lval,any=&gt;any 3 … %= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &lt;&lt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &gt;&gt;&gt;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … &amp;= … 运算且赋值 r-to-l lval,any=&gt;any 3 … ^= … 运算且赋值 r-to-l lval,any=&gt;any 3 … |= … 运算且赋值 r-to-l lval,any=&gt;any 2 yield … 暂停当前gen函数执行，返回表达式的值给gen函数的调用者 r-to-l any=&gt;any 2 yield … 用于在一个gen函数中调用另一个gen函数 r-to-l AnoFn*()=&gt;any 1 … … 展开运算符 r-to-l array=&gt;any 0 , … 忽略第一个操作数，返回第二个操作数 r-to-l any,any=&gt;any 注： l-to-r : left-to-right 左结合 r-to-l : right-to-left 右结合 lval : leftValue 左值 in右侧必须是一个对象。例如，您可以指定使用String构造函数创建的字符串，但不能指定字符串文字。in操作符会检测原型链上的属性。使用delete操作符删除属性，则操作in员返回false该属性。如果将属性设置为undefined但不将其删除，则in该属性的操作符返回true。 instanceof操作符会检测原型链。 关于–,++操作符报错“ReferenceError: Invalid left-hand side expression in postfix operation” ，这里报的是引用错误，其实想想应该可以这么理解因为++ 和 –操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪返？-&gt;肯定需要一个容器，这个容器就是左值. 123456789101112131415161718192021222324252627// ++ --操作符对操作数有要求吗？是不是只能操作左值?//Invalid left-hand side expression in postfix operationvar str = 'abc';console.log(str++); // NaN 说明可以操作字符串//console.log(5++);//ReferenceError: Invalid left-hand side expression in postfix operation 说明不能直接操作值//引用错误：出现这个的原因是因为++ 和 --操作符不能直接操作值类型，因为不管是先自增/自减。还是后自增/自减，总要返回值。那么值往哪放？-&gt;需要一个容器 （因为值是不可变的)var o = &#123;&#125;;console.log(o++); // NaN 说明可以操作对象var b;console.log(b++); //NaN 说明操作数对于undefined也可以接受var obj = null;console.log(obj++); //0 ???why 为什么null会转换成0？var boolF = false;console.log(boolF++); //0 ???whyvar boolT = true;console.log(boolT++); //1 ???why 操作符对数据做了什么？？？关注类型转换 参考来源： 知乎：JavaScript中运算符优先级的问题？@RednaxelaFX 解释器，树遍历解释器，表达式的求值顺序@RednaxelaFX JavaScript yield*操作符 JavaScript 展开运算符 JavaScript剩余参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何避免JavaScript中的冲突]]></title>
      <url>%2F2017%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DJavaScript%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81%2F</url>
      <content type="text"><![CDATA[模块化的本质 全局作用域下变量命名冲突描述：在各自模块内都可以使用，一旦整合到一起发生冲突 123456789101112[1]工程师甲编写功能Avar a = 1;var b = 2;alert(a+b);//3 [2]工程师乙添加新功能Bvar a = 2;var b = 1;alert(a-b);//1 解决方案： 立即执行函数表达式封装实现，让变量作用域控制在匿名函数之内。 123456789101112//功能A(function()&#123; var a = 1; var b = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)(); 匿名函数之间存在依赖描述：C功能依赖于A功能的结果 解决方案：在window作用域下定义一个全局变量,把它作为一个桥梁,完成各匿名函数之间的通信 123456789101112131415161718192021//全局变量var str;//功能A(function()&#123; var a = 1; //将b的值赋给str var b = str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将str的值赋给b var b = str; alert(b);//2&#125;)(); 控制全局下变量数量的方法描述：随着匿名函数之间需要通信的变量越多,需要的全局变量也就越多。因此需要严格控制全局变量的数量 12345678910111213141516171819202122232425262728293031//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; //和功能B使用同一个hash键发生冲突 alert(a+b);//3&#125;)();//功能B(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 2; //和功能A使用同一个hash键发生冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; alert(a*2);//4&#125;)(); 解决方案：使用hash对象作为全局变量,可以将需要的变量都作为对象的属性,可以保证全局变量的个数足够少,同时拓展性非常好 123456789101112131415161718192021222324//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; //将a的值赋给GLOBAL.str1 var a = GLOBAL.str1 = 1; //将b的值赋给GLOBAL.str var b = GLOBAL.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; var a = 2; var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.str1的值赋给a var a = GLOBAL.str1; //将GLOBAL.str的值赋给b var b = GLOBAL.str; alert(a*b);//2&#125;)(); hash键名发生冲突描述：A，B，C，D四个模块分配给4个工程师实现4个功能，C依赖于A，并且使用A中的变量a，b，这个时候A中的变量a，b就需要通过挂载到全局对象GLOBAL上的属性实现A，C之间的通信，GLOBAL作为他们的桥梁。 但是新的需求是功能D需要和功能B通信,并使用功能B脚本中的变量a,开发功能D的是工程师丁。由于工程师丁只关心自己的匿名函数和功能B的匿名函数，使用GLOBAL.str却无意中覆盖了功能A中设置的同名变量,导致功能C出错。 解决方案：于是使用命名空间来解决这个问题，在不同的匿名函数下,根据功能声明一个不同的命名空间,然后每个匿名函数中的GLOBAL对象的属性都不要直接挂在GLOBAL对象上,而是挂在此匿名函数的命名空间下 123456789101112131415161718192021222324252627282930313233//全局变量var GLOBAL = &#123;&#125;;//功能A(function()&#123; GLOBAL.A = &#123;&#125;; //将a的值赋给GLOBAL.A.str1 var a = GLOBAL.A.str1 = 1; //将b的值赋给GLOBAL.A.str var b = GLOBAL.A.str = 2; alert(a+b);//3&#125;)();//功能B(function()&#123; GLOBAL.B = &#123;&#125;; //将a的值赋给GLOBAL.B.str1 var a = GLOBAL.B.str1 = 2; //同名hash引起冲突 var b = 1; alert(a-b);//1&#125;)();//功能C(function()&#123; //将GLOBAL.A.str1的值赋给a var a = GLOBAL.A.str1; //将GLOBAL.A.str的值赋给b var b = GLOBAL.A.str; alert(a*b);//2&#125;)();//功能D(function()&#123; //将GLOBAL.B.str1的值赋给a var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 如果同一个匿名函数中的程序非常复杂,变量名很多,命名空间还可以进一步拓展,生成二级命名空间 123456789101112//以功能A为例(function()&#123; var a = 1, b = 2; GLOBAL.A = &#123;&#125;; GLOBAL.A.CAT = &#123;&#125;; GLOBAL.A.DOG = &#123;&#125;; GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.B.str = b; &#125;)(); 代码的冲突问题已经解决了,但可维护性并不强。比如,现在需要让工程师甲去修改功能B。因为工程师甲写的脚本是关于功能A的,他并不知道功能B的脚本情况。为了改善这种局面,需要给代码添加适当的注释。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var GLOBAL = &#123;&#125;;GLOBAL.namespace = function(str)&#123; var arr = str.split('.'); var o = GLOBAL; var start = 0; if(arr[0] == 'GLOBAL')&#123; start = 1; &#125;else&#123; start = 0; &#125; for(var i = start; i &lt; arr.length; i++)&#123; o[arr[i]] = o[arr[i]] || &#123;&#125;; o = o[arr[i]]; &#125;&#125;;/** @method 功能A:实现加法运算* @author 工程师甲* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 1; var b = 2; GLOBAL.namespace('A.CAT'); GLOBAL.namespace('A.DOG'); GLOBAL.A.CAT.name = 'mimi'; GLOBAL.A.DOG.name = 'xiaobai'; GLOBAL.A.CAT.move = function()&#123;&#125;; GLOBAL.A.str1 = a; GLOBAL.A.str = b; alert(a+b);//3&#125;)();/** @method 功能B:实现减法运算* @author 工程师乙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = 2; var b = 1; GLOBAL.namespace('B'); GLOBAL.B.str1 = a; alert(a-b);//1&#125;)();/** @method 功能C:实现乘法运算* @author 工程师丙* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.A.str1; var b = GLOBAL.A.str; alert(a*b);//2&#125;)();/** @method 功能D:实现乘2运算* @author 工程师丁* @connect 1234567* @time 2015-01-01*/(function()&#123; var a = GLOBAL.B.str1; alert(a*2);//4&#125;)(); 让javascript不再冲突,需要 [1]避免全局变量的泛滥 [2]合理使用命名空间 [3]为代码添加必要的注释 本文转载自 如何避免javascript中的冲突 后话 模块化已经非常普及了，但是模块化解决的根本问题还是如何实现JS的私有空间，如何解决代码的依赖关系，如何避免发生冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用markdown遇到的问题]]></title>
      <url>%2F2017%2F05%2F06%2F%E4%BD%BF%E7%94%A8markdown%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[记录一下使用md时遇到的问题 如何把markdown转换成HTML？描述: 网页上的博客都是.html文件，要把.md文件转换成HTML是上传前的第一步 使用github上的开源库，提供了markdown语法转换为HTML https://github.com/chjj/marked markdown转换为HTML的原理其实就是一个通过一个转换器函数marked，接收MarkDown文本作为输入，输出一段HTML。 markdown的内容本质就是一个大字符串，转换器函数使用正则表达式对这些特殊的标识符进行解析，比如 # ## + - &gt; 。比如 对“# ”【#号后紧跟一个空格的，#号前面没内容，#号作为一行文本的开头，注意前面连空格都不能有】解析就会用一个\标签替换并填充内容，如何判断到哪结束呢？ 解析回车换行符… 注意：对一些特殊字符的解析必须是在开头才有效#表示标题 >表示引用，对于>这种字符的替换要格外注意，这里需要转义，防止XSS。 最后把返回的内容通过操作DOM方式进行文本插值（innerHTML）的方式插入到div容器中.（index.html内） 而node环境下因为没有DOM操作，用模板替换的方式，使用正则把内容替换掉占位符。 md 问题汇总md 插图注意，要在网页上插图，本地的图片是不行的，必须先把本地图片上传到互联网上通过链接的形式插入。 3.2插图时如何自定义图片的宽高？使用md语法进行插图是没办法自定义图片的宽高，但是别忘了，md支持HTML标签的，直接通过img标签的方式设置图片的宽高，md它的本质只是为了让我们抛弃鼠标 在线HTML写md动态转换为真正的HTML1.把MarkDown放在一个容器盒子里面 2.DOM操作获取盒子内容 3.用转换器函数转为HTML，再插入盒子 遇到的问题等解析到脚本的时候转换才开始，那么页面会显示一段原始的文档，如果把脚本位置放在盒子前面，又获取不到文本内容。 md 添加样式反正最终md会被转换为html，在html文件中通过link标签引入一段样式即可。 md 内部添加一些样式可以使用md支持的font标签，支持color，size，face等样式。 所以，总体的样式可以用外部css设置，简单的添加样式可以使用font标签 离线书写md，批量自动转换为HTML描述： 如果通过每次在html页面中书写md，再转换的话，每次会这样，复制一遍之前的html（因为里面包含了css和转换器脚本），复制自己的md文件内容，覆盖html中的md，然后另存为一个新的html。很费劲… 如何可以根据我们的md文件自动生成对应的html文件呢？？？ 使用Node ，Node是一个JavaScript运行时，提供了我们不依赖浏览器允许脚本的能力，同时它还提供了一些操作文件的API。使用这些API编写脚本可以自动地完成我们的需求。 前置工作： 1.编写一个index.html文件作模板，里面把样式和js加载写好，并设置一个容器盒子，里面放上占位符2.在博客项目的目录下新建一个md文件夹，用来管理存放所有的md文件。 注意：好的习惯可以屏蔽掉一些不必要的操作。 使用文件夹分类管理的思路就是使用软件中的分而治之思想如果把项目目录抽象成一个大object，那么以下的每个文件夹就是子object或者Array。 比如 src目录 就是一个子object,里面可以用css,js,image这些文件夹进行分类管理。而类似于md这种文件夹就像Array，里面就存放了同一类内容，就是我们的博客文件。 利用node 读写目录和文件的API完成自动转换的任务 1.读md目录下的文件 2.读取md文件的内容和模板的内容 3.使用正则对模板和内容进行替换 4.保存（写入文件）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的github]]></title>
      <url>%2F2017%2F04%2F25%2F%E6%88%91%E7%9A%84github%2F</url>
      <content type="text"><![CDATA[前言 每一个开始都是基于痛点的产生 起因 从大学时学JAVA时,就听到老师科普说github就是程序员的微博,在那上面,可以学到很多世界级程序员的代码以及思考问题的方式。但是第一次的github之旅因为英文困扰而快速地点击了右上角。反正又没什么用,有用的话我看中文的博客呗,这算是最早接触把,也因为英文那点事而告终。后来接触github是快毕业的时候,做毕业设计,想找点资源啊,去哪找呢?github上资源多啊,没办法啊,要毕业啊,要做项目,抱着目的的心情,英文这头拦路虎似乎也不是那么可怕了。当时的那个github账号因为第一次算比较”正式”地使用吧,不停地Fock、Star一堆项目,看到介绍不错的先收藏起来,导致最后那个github账号被放弃。这次写下这篇感想也是开始真正准备使用github了 为什么使用github? 每个人遇到的问题不同,让你对一个工具的感触也不同。别人给你说得再多好,也不及你真正遇到痛点的时候,突然出现一样工具,可以瞬间解决你的各种烦恼带来的那种快感。对于我来说,之前也练习过不少代码,一些各种小demo,一些PC页面重构,移动站点的重构,框架的初使用,那会也对代码进行了一些分类管理,但是尽管如此,还是存在很大的问题,比如说每次遇到问题,去网上找了一些解决方案和代码,自己理解以后重写了一份,但是因为太过随意,不知道保存到了哪个角落里-&gt;随意性,而有了github会怎么样呢?github上仓库是可见的啊,你的代码是会展示给别人看的,当然作为喽啰的我是不会有人看的,但是总能下意识地规范自己的行为。其次,每个仓库可以分类管理代码,方便代码的管理,每次写的时候去github上pull,写完代码push。这看似很麻烦,这也是当初我抗拒github的原因,但实际能让我们养成一个良好的习惯,而不是每次到处在硬盘里找。 感悟 简单与复杂,容易与困难。简单=&gt;困难,复杂 === 完善 =&gt; 容易]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript复合类型的隐式转换]]></title>
      <url>%2F2017%2F04%2F09%2FJavaScript%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[为什么很重要在你的编写的代码中,类型转换无处不在。而对于”隐式”转换它就像一个昙花一现般,短暂地出现却又很快地消失。比如:12var arr = [1,2,3];alert(a); 这样类似的代码写的不在少数吧?可是对于alert()这个函数,你知道它接收的参数类型是一个字符串吗?诶不对啊,这里明明传入了一个Array,而且正常显示了,没有报错啊。这就是神秘的隐式转换,悄悄地对你的参数做了转换,最后显示在控制台上。下面来看几段代码123456789101112131415161718var bbb = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bbb);// 10 toString alert(+bbb); // 10 valueOf alert(''+bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == '10'); // true valueOf alert(bbb === '10'); // false 重写两个方法的情况下，如果要输出一个对象，那么会输出什么样的值？如何对对象进行类型转换的？ 从第一个alert()中得到的结果是,输出对象值的时候,实际上调用了对象的toString()方法。 重写两个方法的情况下，加号操作符对对象会产生什么行为？一个加号操作符加一个操作数会发生什么? 加号操作符让对象调用了valueOf()方法。+bb是+ 运算符的一元(unary)形式，(即只有一个操作数)，+运算符显示地将bb转换为数字。 重写两个方法的情况下，字符串，加号操作符对对象产生什么行为？ 字符串，加号操作符让对象调用了valueOf()方法,但是为什么会是valueOf而不是toString()方法呢?这里明明看上去就是字符串拼接啊。 “在有操作符的情况下,valueOf()的优先级比toString()更高” 想要理解这个其实不难,+号操作符和对象在一起时,首先会被认为是一个值运算,所以会调用valueOf()返回一个数值,其次因为加号操作符的两边一边是字符串,一边是数字,对于这种,JavaScript红宝书上是这么说的: 如果只有一个操作数是字符串,则将另一个操作数转换为字符串,然后再将两个字符串拼接起来。 于是数值又悄悄地进行了一次转换String(),看似简单的结果背后实则发生了两次类型转换,类型转换是不是无处不在? 重写两个方法的情况下，把对象显示地转换成字符串会产生什么行为？ 调用对象的toString()方法转换为基本值 重写两个方法的情况下，把对象显示地转换为数字会产生什么行为？ 调用对象的valueOf()方法转换为数值 一个对象如何和一个基本类型进行比较？ 复合类型(对象/数组)先通过valueOf()或者toString()转换为基本类型 根据基本数据类型的比较规则进行类型转换最终比较出结果 JavaScript中的valueOf方法和toSting方法是干什么的？ 把复合类型转换为基本类型 为什么实际中很少调用valueOf()和toString()，但他们还这么重要？ 因为它总在你不知道的时候悄悄地被调用 那么何时调用toString()方法,何时调用valueOf()方法呢?1234567891011121314151617181920212223242526272829一个具有重写的toString()，一个具有重写的valueOf()var aa = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;&#125;alert(aa);// 10 toStringalert(+aa); // 10 toStringalert(''+aa); // 10 toStringalert(String(aa)); // 10 toStringalert(Number(aa)); // 10 toStringalert(aa == '10'); // true toStringvar bb = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(bb);// [object Object]alert(+bb); // 10 valueOfalert(''+bb); // 10 valueOfalert(String(bb)); // [object Object]alert(Number(bb)); // 10 valueOfalert(bb == '10'); // true valueOf 只重写toString的情况下，以上问题会发生什么样的行为变化？1234567891011121314输出：调用toString()转换为基本类型值值运算：没调用valueOf()了，而是调用了toString()转换为了数值，即使修改i=“10”,并且打印值的类型，还是数字，而不是字符串。这说明先通过toString()转化为基本数据类型，再通过Number()把字符串转换为数字。分析：1.重写toString方法比原始valueOf方法的优先级，所以复合类型先调用toString()转换为基本类型。2.因为是值运算，所以基本类型string经过Number()二次转换为number。如何验证:aa.i = “10&quot;;alert(+aa); // 10 toStringalert(typeof +aa); // number字符串+对象： 1.调用重写的toString()转换为基本类型 2.数值类型转为字符串类型进行拼接 对象显示转化字符串： 1.调用重写的toString()转换为基本类型Str对象显示转换为数值： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number 相等判断： 1.调用重写的toString()转换为基本类型Str 2.String转换为Number再进行比较-&gt;相等 只重写valueOf的情况下，以上问题会发生什么样的行为变化？1234567输出：1.并没有调用重写的valueOf，而是调用默认的toString()方法，显示[对象 类型]值运算:1.调用重写的valueOf()，转换为基本类型值Number字符串+对象：1.调用重写的valueOf()转换为基本类型值Number 2.转换为str进行拼接 对象显示转化字符串：1.没有调用重写的valueOf()，而是直接调用了默认地toString对象显示转换为数值：1.调用重写的valueOf()转换为基本类型值Number相等判断：1.调用重写的valueOf()转换为基本类型值Number 去掉从Object继承的toString方法的干扰，以上问题会发生什么样的变化？1234567891011121314Object.prototype.toString = null;var cc = &#123; i: 10, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125;&#125;alert(cc);// 10 valueOfalert(+cc); // 10 valueOfalert(''+cc); // 10 valueOfalert(String(cc)); // 10 valueOfalert(Number(cc)); // 10 valueOfalert(cc == '10'); // true valueOf 因为默认地toString方法没了，所以只能调用重写的valueOf() 总结0.基本上，所有JS数据类型都拥有valueOf和toString这两个方法，null除外。它们俩解决javascript值运算与显示的问题。 还有一个对象没有valueOf()和toString()方法，通过Object.create(null)创建的对象[[Prototype]]属性为null1.toString()用于显示，valueOf()用于值运算。2.默认情况下，根据不同的操作，两个方法的优先级不同。3.在有操作符的情况下，valueOf的优先级比toString高。4.重写会加大它们自动调用的优先级。5.重写toString的情况下，toString()方法会无视valueOf()，1.都会先调用toString()方法转换为基本类型的值，此时如果是”显示”操作就到此为止2.如果是值运算，基本类型的值转化为Number类型进行值运算.6.重写valueOf的情况下，值运算优先调用valueOf，显示地转换为字符串&amp;输出会调用默认地toString()。valueOf()不管返回的是什么基本值，值运算都会对其转换为数值.7.在进行强转字符串的时候将优先调用toString().]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符集和字符编码]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[首先,在了解字符集和字符编码是什么之前先去看看为什么会有字符集和字符编码,它是为了解决什么问题? 字符集的产生我们平时在计算机屏幕上看到的文字内容并不是直接以文字的形式存储在计算机的存储介质中,计算机存储介质中存放的实际上是二进制的比特流。也就是说,不论你在计算机上看到的汉字,英文字母,日文等等,一旦存入计算机存储介质中,最终都是以010101010形式存放。那么如何确保拿出来转换的是汉字不是日文呢?显然,在这两者之间的转换就需要一个统一的规则,不然,当你把文档发给别人,别人的转换规则和你不一样,岂不是就出现乱码了? 所以为了统一转换,字符集就诞生了。简单的说,字符集规定了某个文字对应的二进制数字存放方式(编码)和某串二进制数值代表了哪个文字(解码)的转换关系。 “字符集”就像谍战片中的“译码本”一样,发电报时,大家发送的都是”滴答滴答”的原始信息,但是通过译码本,就可以转换成真实的字符。就像译码本一样,同样的原始信息经过不同的译码本翻译可能得到不同的结果;对于相同的一个字经过不同的译码本转换,翻译出的内容也不一样,这也就是为什么谍战片中大家都这么重视译码本。 对于一个字符集来说要正确编码转码一个字符需要三个关键元素:字库表(character repertoire)、编码字符集(coded character set)、字符编码(character encoding form)。 字库表 是一个相当于所有可读或者可现实字符的数据库,字库表决定了整个字符集能够展示的所有字符的范围。 编码字符集 即用一个编码值code point来表示一个字符在字库中的位置。 字符编码 将编码字符集和实际存储数值之间的转换关系。一般来说都会直接将code point的值作为编码后的值直接存储(ASCII中) 这么看来,字库表和编码字符集看来是必不可少的,既然字库表已经有序号了那为什么不直接把序号作为存储内容呢?干嘛还要多此一举通过字符编码把序号转换成另一种存储格式呢? 因为统一字库表的目的是为了能够涵盖世界上所有的字符,但实际使用的过程中呢,真正用到的字符占字库表的比例是非常低的。比如老美,他们仅仅可能仅仅只用到了ASCII中的128个字符,但是如果都以字库表中的序号来存储的话,原本ASCII中的一个字符只占一个字节,现在一个字符占了三个字节,这显然对他们很不友好。这个时候就出现了UTF-8这样的变成编码。在UTF-8编码中,原本只占一个字节的ASCII字符,仍然只占一个字节。 为什么会有Unicode字符集编码标准?因为ASCII是美国人自己用的,ASCII开始普及之后,各国针对ASCII字符不够自己国家/地区使用,在ASCII上做了扩展,因为此,出现了同一个二进制编码表示不同编码的问题。解决了一个字节不够表示全球中所有符号的问题。 UTF-8和Unicode的关系Unicode就是字符集编码，而UTF-8就是字符编码,就是Unicode规则字库的一种实现形式。unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节)。从unicode到UTF-8并不是直接的对应，而是要过一些算法和规则来转换。UTF-8编码的实现方法，即UTF-8的物理存储和Unicode序号的转换关系。 为什么会出现乱码?编码和解码时使用了不同的字符集。对于字符”很屌”经过UTF-8编码后,它的十六进制表示E5BE88E5B18C这串数字,而我们显示的时候用GBK解码进行展示。(GBK的解码规则是:对于一个字节，如果它是小于127的，那么它就是一个英文单字节。而如果某个字节是大于127，就表示是一个汉字的开始.所以当时会有1个汉字2个英文字符的说法),此时GBK会把这串数字拆成 E5BE 88E5 B18C三组,每组两个字节,所以GBK解码后就成了寰堝睂三个字符。不仅和原来的完全不一样还多了一个。 出现乱码后如何识别原来的想要表达文字? 编码(发现乱码的当前编码,转回二进制) 切割(获取二进制字符串并按字节拆成字节数组) 解码 最后补充一下计算机中存的是二进制,但是常见的用十六进制表示而不用十进制?或者其他八进制?因为二进制过长的数字代码对于阅读带来不便,十进制和二进制没有指数型关系。十六进制简洁且和二进制成倍数关系,两个十六进制就可以表示8个二进制位也就是一个字节。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像程序员般思考]]></title>
      <url>%2F2017%2F04%2F04%2F%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%88%AC%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[平常我们在学习的过程中,比如遇到一个新的术语,新的概念或者所有对于你来说都是未知的”新”东西,你下意识会选择怎么办?我不知道你会怎么办?反正之前的我会先选择维基百科一下看看它是什么(What),然后映入眼前的是大篇幅官方描述,此时如果你有相关领域的经历或者经验(底蕴),很好,轻而易举地理解了它在表述什么,但是如果你之前没有接触过呢?想必看完也是一头雾水。比如socket这个词,你搜词典,它上面的解释”插座,给…配插座”,当然更强大一点的词典,比如有道,它还有网络释义套接字,很好,词典很强大,和维基百科说的也是一样的。 在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 socket是一种操作系统提供的进程间通信机制。[1]socket最初被翻译为把socket译为“媒介(字)”[2]。不久，ARPANET的socket就被翻译为“套接字”，其理由是：[3] 通过这段话,我们得出了几个信息: What:套接字 Do:用于进程间通信 通过这些信息加上我们的”理解”看似已经达到了我们从无到有的认识过程。但这是不属于你的,因为这其实只是凭借着我们大脑的记忆能力强行地进行了一下复制粘贴。这样不牢固的东西是不稳的,就像天龙八部里的慕容复,看似武学渊博,什么都会,名头响亮。但其实他就像一个瓷器,当遇到真正的高手时,就暴露出了问题。因为他无一精通,没有自己的见解,都是照搬别人。但高手之间的对决,往往是变幻莫测的。这就好像我们的程序,完成需求是容易的,难得是维护和迭代。回到socket的问题上,既然是表示网络进程通信为什么不叫Web Communication,这样不更容易理解一下吗?诶,好像这么说也有道理啊,是不是此时感觉之前对socket的理解又动摇了呢?这就是知其然而不知其所以然带来的后果,其实我们真正在看到的一个”新”(可能对于你来说是)的问题时,应该建立这样一个思考问题的过程 为什么会产生这个问题?因为这是人类社会,凡事不会凭空发生,肯定有原因。我觉得了解为什么是拨开神秘面纱的第一步。 其次是How 然后才是What 最后再去建立和别的事物的联系,回头再思考下有什么不足 而对于高明的程序员来说,这其实就是他们的本能的思考和解决问题的行为。 回到socket的产生上,直到我在知乎上看到一篇帖子“Socket为什么要翻译成套接字？”中陈振玥先生的回答才让我反思写下这篇博客记录下——面对于一个未知问题的思考方式。里面大致是这么说的:最早“网络连接”这个词对于那个时代还是一个新兴词汇。当时的网络连接对于大部分人来说是无法理解其含义的,所以作者为了解释清楚,才有了socket,原意想表达的就是建立网络连接就像插插座一样,一方去插,而另一方被插,这就是socket的由来。但是为什么后来变成了套接字呢?这其实更容易理解了,随着发展,大家理解了网络连接的过程,“网络连接”比起早期更复杂了,它被发扬光大了,所以基于这两种情况,插插座这种狭义理解已经不太符合它的定位了。 1. 人类认知的上升 2. 职责的增大 而应试教育和急于求成的心理或多或少地让我们变得浮躁,应试教育让我们的思想变得僵硬,你可以说你在做一道数学题的时候是有在思考问题,但是其实我觉得只能算一半。急于求成的心理往往使我们遇到问题直接询问或者查找如何解决,不加一点地思考,不追根溯源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo搭建静态博客]]></title>
      <url>%2F2017%2F02%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[官方文档：https://hexo.io/github地址：https://github.com/hexojs/hexo主题文档： Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
